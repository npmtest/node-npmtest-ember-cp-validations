{"/home/travis/build/npmtest/node-npmtest-ember-cp-validations/test.js":"/* istanbul instrument in package npmtest_ember_cp_validations */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-ember-cp-validations/lib.npmtest_ember_cp_validations.js":"/* istanbul instrument in package npmtest_ember_cp_validations */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_ember_cp_validations = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_ember_cp_validations = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-ember-cp-validations/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-ember-cp-validations && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_ember_cp_validations */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_ember_cp_validations\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_ember_cp_validations.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_ember_cp_validations.rollup.js'] =\n            local.assetsDict['/assets.npmtest_ember_cp_validations.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_ember_cp_validations.__dirname + '/lib.npmtest_ember_cp_validations.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-ember-cp-validations/node_modules/ember-cp-validations/index.js":"/**\n * Copyright 2016, Yahoo! Inc.\n * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\n/* jshint node: true */\n'use strict';\n\nmodule.exports = {\n  name: 'ember-cp-validations',\n\n  setupPreprocessorRegistry: function(type, registry) {\n    var VGet = require('./htmlbars-plugins/v-get');\n\n    registry.add('htmlbars-ast-plugin', {\n      name: 'v-get',\n      plugin: VGet,\n      baseDir: function() {\n        return __dirname;\n      }\n    });\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-ember-cp-validations/node_modules/ember-cp-validations/config/changelog.js":"// jshint node:true\n\n// For details on each option run `ember help release`\nmodule.exports = {\n\n  // angular style guide: https://github.com/angular/angular.js/blob/v1.4.8/CONTRIBUTING.md#commit\n  // jquery style guide: https://contribute.jquery.org/commits-and-pull-requests/#commit-guidelines\n  // ember style guide: https://github.com/emberjs/ember.js/blob/master/CONTRIBUTING.md#commit-tagging\n  style: 'angular', // 'ember' 'jquery'\n\n  head: 'master',\n  base: '-last', // a branch or tag name, `-last` defaults to the version in package.json\n\n  hooks: {\n    /*\n     parser: function(commit) { return commit; }\n     filter: function(commit) { return true; },\n     groupSort: function(commits) { return { commits: commits }; },\n     format: function(commit) { return commit.title; },\n     */\n  }\n\n};\n","/home/travis/build/npmtest/node-npmtest-ember-cp-validations/node_modules/ember-cp-validations/config/environment.js":"/**\n * Copyright 2016, Yahoo! Inc.\n * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n/* jshint node:true */\n'use strict';\n\nmodule.exports = function( /* environment, appConfig */ ) {\n  return {};\n};\n","/home/travis/build/npmtest/node-npmtest-ember-cp-validations/node_modules/ember-cp-validations/config/release.js":"/* jshint node:true */\n\nvar execSync = require('child_process').execSync;\nvar generateChangelog = require('ember-cli-changelog/lib/tasks/release-with-changelog');\n\nmodule.exports = {\n  publish: true,\n\n  beforeCommit: generateChangelog,\n\n  afterPublish: function(project, versions) {\n    runCommand('ember github-pages:commit --message \"Released ' + versions.next + '\"');\n    runCommand('git push origin gh-pages:gh-pages');\n  }\n};\n\nfunction runCommand(command) {\n  console.log('running: ' + command);\n  var output = execSync(command, { encoding: 'utf8' });\n  console.log(output);\n}\n","/home/travis/build/npmtest/node-npmtest-ember-cp-validations/node_modules/ember-cp-validations/htmlbars-plugins/v-get.js":"/**\n * @module Templating\n * @main Templating\n */\n\n/**\n * Accessing validation information in your templates is really simple but the pathing can be quite long. For example, if we want to display the error `message` for the `username` attribute, it would look something like this:\n *\n * ```handlebars\n * {{model.validations.attrs.username.message}}\n * ```\n *\n * ## The V-Get Helper\n * To bypass such long pathing, you can use the `v-get` helper.\n *\n * _**Notice**: Ember v1.13.0 is not supported due to a bug. Please use Ember v1.13.1 and higher or Ember v1.12.* and lower_\n *\n * **Access global model properties**\n *\n * ```handlebars\n * {{v-get model 'isValid'}}\n * ```\n *\n * **Access attribute specific properties**\n *\n * ```handlebars\n * {{v-get model 'username' 'message'}}\n * ```\n *\n * **Access model relationship validations**\n *\n * Say we have a `user` model with a `details` attribute that is a belongsTo relationship, to access validations on the `details` attribute/model we can access it as such.\n *\n * ```handlebars\n * {{v-get model.details 'isValid'}}\n * {{v-get model.details 'firstName' 'message'}}\n * ```\n *\n * What's awesome about this is that you can pass in bound properties!\n *\n * ```handlebars\n * {{v-get model attr prop}}\n * {{v-get model prop}}\n * ```\n *\n * Here is a more extensive example:\n * ```handlebars\n * <form>\n *   {{input value=model.username placeholder=\"Username\"}}\n *   {{#if (v-get model 'username' 'isInvalid')}}\n *     <div class=\"error\">\n *       {{v-get model 'username' 'message'}}\n *     </div>\n *   {{/if}}\n    *\n *   <button type=\"submit\" disabled={{v-get model 'isInvalid'}}>Submit</button>\n * </form>\n * ```\n *\n * @module Templating\n * @submodule V-Get Helper\n */\n\n /*jshint node:true*/\n\nfunction VGet(options) {\n  this.options = options;\n  this.syntax = null; // set by HTMLBars\n}\n\nVGet.prototype.transform = function(ast) {\n  var context = this;\n  var walker = new this.syntax.Walker();\n\n  walker.visit(ast, function(node) {\n    if (context.validate(node)) {\n      context.processNode(node);\n    }\n  });\n\n  return ast;\n};\n\nVGet.prototype.validate = function(node) {\n  return ['BlockStatement', 'MustacheStatement', 'ElementNode'].indexOf(node.type) > -1;\n};\n\nVGet.prototype.processNode = function(node) {\n  var type = node.type;\n  node = unwrapNode(node);\n\n  // {{v-get model 'username' 'isValid'}}\n  if (type === 'MustacheStatement' && node.path.original === 'v-get') {\n    this.transformToGet(node);\n  }\n\n  this.processNodeParams(node);\n  this.processNodeHash(node);\n  this.processNodeAttributes(node);\n};\n\n/**\n * {{#if (v-get model 'username' 'isValid')}} {{/if}}\n * @param  {AST.Node} node\n */\nVGet.prototype.processNodeParams = function(node) {\n  if (node.params) {\n    for (var i = 0; i < node.params.length; i++) {\n      var param = node.params[i];\n      if (param.type === 'SubExpression') {\n        if (param.path.original === 'v-get') {\n          this.transformToGet(param);\n        } else {\n          this.processNode(param);\n        }\n      }\n    }\n  }\n};\n\n/**\n * {{x-component prop=(v-get model 'isValid')}}\n * @param  {AST.Node} node\n */\nVGet.prototype.processNodeHash = function(node) {\n  if (node.hash && node.hash.pairs) {\n    for (var i = 0; i < node.hash.pairs.length; i++) {\n      var pair = node.hash.pairs[i];\n      if (pair.value.type === 'SubExpression') {\n        if (pair.value.path.original === 'v-get') {\n          this.transformToGet(pair.value);\n        } else {\n          this.processNode(pair.value);\n        }\n      }\n    }\n  }\n};\n\n/**\n * <button type=\"submit\" disabled={{v-get model 'isInvalid'}}>Submit</button> (node.attributes)\n * <div class=\"form-group {{if (v-get model 'isInvalid') 'has-error'}}\">\n * @param  {AST.Node} node\n */\nVGet.prototype.processNodeAttributes = function(node) {\n  var i;\n  if (node.attributes) {\n    for (i = 0; i < node.attributes.length; i++) {\n      var attr = node.attributes[i];\n      this.processNode(attr.value);\n    }\n  }\n\n  if (node.parts) {\n    for (i = 0; i < node.parts.length; i++) {\n      this.processNode(node.parts[i]);\n    }\n  }\n};\n\n\n/**\n * Transform (v-get model 'username' 'isValid') to (get (get model.validations.attrs 'username') 'isValid') OR\n * (v-get model 'isValid') to (get model.validations 'isValid')\n * @param  {AST.Node} node\n * @return {AST.Node}\n */\nVGet.prototype.transformToGet = function(node) {\n  node = unwrapNode(node);\n  var params = node.params;\n  var i = 0;\n\n  if (params.length < 2) {\n    throw new Error('{{v-get}} requires at least two arguments');\n  }\n  if (params[0].type !== 'PathExpression') {\n    throw new Error('The first argument to {{v-get}} must be a stream');\n  }\n\n  var root = this.syntax.builders.path(params[i++].original + '.validations');\n\n  if (params.length === 3) {\n    root = this.syntax.builders.path(root.original + '.attrs');\n    root = this.syntax.builders.sexpr(this.syntax.builders.path('get'), [root, params[i++]]); // (get model.validations.attrs 'username')\n  }\n\n  node.path = this.syntax.builders.path('get');\n  node.params = [root, params[i]];\n\n};\n\n// For compatibility with pre- and post-glimmer\nfunction unwrapNode(node) {\n  if (node.sexpr) {\n    return node.sexpr;\n  } else {\n    return node;\n  }\n}\n\nmodule.exports = VGet;\n","/home/travis/build/npmtest/node-npmtest-ember-cp-validations/node_modules/ember-cp-validations/addon/-private/ember-validator.js":"import Base from 'ember-cp-validations/validators/base';\nimport { validate as _validate } from 'ember-validators';\n\nexport default Base.extend({\n  validate() {\n    let result = _validate(this.get('_evType'), ...arguments);\n\n    if (result && typeof result === 'object') {\n      return result.message ? result.message : this.createErrorMessage(result.type, result.value, result.context);\n    }\n\n    return result;\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-ember-cp-validations/node_modules/ember-cp-validations/addon/-private/internal-result-object.js":"/**\n * Copyright 2016, Yahoo! Inc.\n * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\nimport Ember from 'ember';\nimport ValidationError from '../validations/error';\nimport { isDsModel, isPromise } from '../utils/utils';\n\nconst {\n  get,\n  set,\n  isNone,\n  computed,\n  canInvoke,\n  makeArray,\n  defineProperty\n} = Ember;\n\nconst {\n  and,\n  not,\n  readOnly\n} = computed;\n\nexport default Ember.Object.extend({\n  model: null,\n  isValid: true,\n  isValidating: false,\n  message: null,\n  attribute: '',\n\n  attrValue: null,\n  _promise: null,\n  _validator: null,\n  _type: readOnly('_validator._type'),\n\n  init() {\n    this._super(...arguments);\n\n    defineProperty(this, 'attrValue', computed.readOnly(`model.${get(this, 'attribute')}`));\n\n    if (this.get('isAsync')) {\n      this._handlePromise();\n    }\n  },\n\n  isInvalid: not('isValid'),\n  isNotValidating: not('isValidating'),\n  isTruelyValid: and('isNotValidating', 'isValid'),\n\n  isAsync: computed('_promise', function() {\n    return isPromise(get(this, '_promise'));\n  }),\n\n  isDirty: computed('attrValue', function() {\n    let model = get(this, 'model');\n    let attribute = get(this, 'attribute');\n    let attrValue = get(this, 'attrValue');\n\n    // Check default model values\n    if (isDsModel(model) && canInvoke(model, 'eachAttribute')) {\n      let attrMeta = model.get('constructor.attributes').get(attribute);\n\n      if (attrMeta) {\n        let { defaultValue } = attrMeta.options;\n\n        if (!isNone(defaultValue)) {\n          return defaultValue !== attrValue;\n        }\n      }\n    }\n    return !isNone(attrValue);\n  }),\n\n  messages: computed('message', function() {\n    return makeArray(get(this, 'message'));\n  }),\n\n  error: computed('isInvalid', 'type', 'message', 'attribute', function() {\n    if (get(this, 'isInvalid')) {\n      return ValidationError.create({\n        type: get(this, '_type'),\n        message: get(this, 'message'),\n        attribute: get(this, 'attribute')\n      });\n    }\n\n    return null;\n  }),\n\n  errors: computed('error', function() {\n    return makeArray(get(this, 'error'));\n  }),\n\n  _handlePromise() {\n    set(this, 'isValidating', true);\n\n    get(this, '_promise').finally(() => {\n      set(this, 'isValidating', false);\n    });\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-ember-cp-validations/node_modules/ember-cp-validations/addon/-private/options.js":"import Ember from 'ember';\nimport { isDescriptor } from 'ember-cp-validations/utils/utils';\n\nconst {\n  get,\n  set,\n  defineProperty\n} = Ember;\n\nconst Options = Ember.Object.extend({\n  model: null,\n  attribute: null,\n\n  // Private\n  __options__: null,\n\n  init() {\n    this._super(...arguments);\n\n    let options = this.get('__options__');\n\n    Object.keys(options).forEach((key) => {\n      let value = options[key];\n\n      if (isDescriptor(value)) {\n        defineProperty(this, key, value);\n      } else {\n        set(this, key, value);\n      }\n    });\n  },\n\n  copy(deep) {\n    let options = this.get('__options__');\n\n    if (deep) {\n      return Options.create({\n        model: get(this, 'model'),\n        attribute: get(this, 'attribute'),\n        __options__: options\n      });\n    }\n\n    return Ember.Object.create(Object.keys(options).reduce((obj, o) => {\n      obj[o] = get(this, o);\n      return obj;\n    }, {}));\n  }\n});\n\nexport default Options;\n","/home/travis/build/npmtest/node-npmtest-ember-cp-validations/node_modules/ember-cp-validations/addon/-private/result.js":"/**\n * Copyright 2016, Yahoo! Inc.\n * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\nimport Ember from 'ember';\nimport ResultCollection from '../validations/result-collection';\nimport InternalResultObject from './internal-result-object';\n\nconst {\n  get,\n  set,\n  isNone,\n  isArray,\n  computed,\n  setProperties,\n  getProperties\n} = Ember;\n\nconst {\n  readOnly\n} = computed;\n\n/**\n * __PRIVATE__\n *\n * @module Validations\n * @class Result\n * @private\n */\n\nconst Result = Ember.Object.extend({\n\n  /**\n   * @property model\n   * @type {Object}\n   */\n  model: null,\n\n  /**\n   * @property attribute\n   * @type {String}\n   */\n  attribute: '',\n\n  /**\n   * @property _promise\n   * @async\n   * @private\n   * @type {Promise}\n   */\n  _promise: null,\n\n  /**\n   * The validator that returned this result\n   * @property _validator\n   * @private\n   * @type {Validator}\n   */\n  _validator: null,\n\n  /**\n   * Determines if the _validations object is readOnly.\n   *\n   * This is needed because ResultCollections and global validation objects control their own\n   * state via CPs\n   *\n   * @property _isReadOnly\n   * @private\n   * @readOnly\n   * @type {Boolean}\n   */\n  _isReadOnly: computed('_validations', function() {\n    let validations = get(this, '_validations');\n    return (validations instanceof ResultCollection) || get(validations, 'isValidations');\n  }).readOnly(),\n\n  /**\n   * @property isWarning\n   * @readOnly\n   * @type {Boolean}\n   */\n  isWarning: readOnly('_validator.isWarning'),\n\n  /**\n   * @property isValid\n   * @readOnly\n   * @type {Boolean}\n   */\n  isValid: readOnly('_validations.isValid'),\n\n  /**\n   * @property isInvalid\n   * @readOnly\n   * @type {Boolean}\n   */\n  isInvalid: readOnly('_validations.isInvalid'),\n\n  /**\n   * @property isValidating\n   * @readOnly\n   * @type {Boolean}\n   */\n  isValidating: readOnly('_validations.isValidating'),\n\n  /**\n   * @property isTruelyValid\n   * @readOnly\n   * @type {Boolean}\n   */\n  isTruelyValid: readOnly('_validations.isTruelyValid'),\n\n  /**\n   * @property isAsync\n   * @readOnly\n   * @type {Boolean}\n   */\n  isAsync: readOnly('_validations.isAsync'),\n\n  /**\n   * @property isDirty\n   * @readOnly\n   * @type {Boolean}\n   */\n  isDirty: readOnly('_validations.isDirty'),\n\n  /**\n   * @property message\n   * @readOnly\n   * @type {String}\n   */\n  message: readOnly('_validations.message'),\n\n  /**\n   * @property messages\n   * @readOnly\n   * @type {Array}\n   */\n  messages: readOnly('_validations.messages'),\n\n  /**\n   * @property error\n   * @readOnly\n   * @type {Object}\n   */\n  error: readOnly('_validations.error'),\n\n  /**\n   * @property errors\n   * @readOnly\n   * @type {Array}\n   */\n  errors: readOnly('_validations.errors'),\n\n  /**\n   * This hold all the logic for the above CPs. We do this so we can easily switch this object out with a different validations object\n   * @property _validations\n   * @private\n   * @type {Result}\n   */\n  _validations: computed('model', 'attribute', '_promise', '_validator', function() {\n    return InternalResultObject.create(getProperties(this, ['model', 'attribute', '_promise', '_validator']));\n  }),\n\n  init() {\n    this._super(...arguments);\n\n    if (get(this, 'isAsync') && !get(this, '_isReadOnly')) {\n      this._handlePromise();\n    }\n  },\n\n  /**\n   * Update the current validation result object with the given result\n   * - If result is undefined or null, set isValid to false\n   * - If result is a validations object from a different model/object, set the _validations object to the one given (belongs-to)\n   * - If result is a collection of result objects, create a Validation Result Collection and set that to the _validations object (has-many)\n   * - If result is a string, set the message to the given string and set isValid to false\n   * - If result is a boolean, set isValid to result\n   * - If result is a pojo, update _validations object with the information given\n   *\n   * @method update\n   * @private\n   * @param result\n   */\n  update(result) {\n    let validations = get(this, '_validations');\n    let validator = get(this, '_validator');\n    let { model, attribute } = getProperties(this, ['model', 'attribute']);\n\n    if (isNone(result)) {\n      this.update(false);\n      return;\n    }\n\n    if (get(result, 'isValidations')) {\n      set(this, '_validations', result);\n    } else if (isArray(result)) {\n      let validationResultsCollection = ResultCollection.create({\n        attribute,\n        content: result.map((r) => Result.create({\n          attribute,\n          model,\n          _validator: validator,\n          _validations: r\n        }))\n      });\n      set(this, '_validations', validationResultsCollection);\n    } else if (!get(this, '_isReadOnly')) {\n      if (typeof result === 'string') {\n        setProperties(validations, {\n          message: result,\n          isValid: false\n        });\n      } else if (typeof result === 'boolean') {\n        set(validations, 'isValid', result);\n      } else if (typeof result === 'object') {\n        setProperties(validations, result);\n      }\n    }\n  },\n\n  /**\n   * Promise handler\n   * @method _handlePromise\n   * @private\n   */\n  _handlePromise() {\n    get(this, '_promise').then(\n      (result) => this.update(result),\n      (result) => this.update(result)\n    ).catch((reason) => {\n      // TODO: send into error state\n      throw reason;\n    });\n  }\n});\n\nexport default Result;\n","/home/travis/build/npmtest/node-npmtest-ember-cp-validations/node_modules/ember-cp-validations/addon/utils/assign.js":"/**\n * Copyright 2016, Yahoo! Inc.\n * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\n/**\n * Assigns a value to an object via the given path while creating new objects if\n * the pathing requires it. If the given path is `foo.bar`, it will create a new object (obj.foo)\n * and assign value to obj.foo.bar. If the given object is an Ember.Object, it will create new Ember.Objects.\n */\nimport Ember from 'ember';\n\nconst {\n  get,\n  set,\n  isNone,\n  defineProperty\n} = Ember;\n\nexport default function assign(obj, path, value, useEmberObject = false, delimiter = '.') {\n  let keyPath = path.split(delimiter);\n  let lastKeyIndex = keyPath.length - 1;\n  let currObj = obj;\n\n  // Iterate over each key in the path (minus the last one which is the property to be assigned)\n  for (let i = 0; i < lastKeyIndex; ++i) {\n    let key = keyPath[i];\n\n    // Create a new object if it doesnt exist\n    if (isNone(get(currObj, key))) {\n      set(currObj, key, useEmberObject ? Ember.Object.create() : {});\n    }\n    currObj = get(currObj, key);\n  }\n\n  if (value instanceof Ember.ComputedProperty) {\n    defineProperty(currObj, keyPath[lastKeyIndex], value);\n  } else {\n    set(currObj, keyPath[lastKeyIndex], value);\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-ember-cp-validations/node_modules/ember-cp-validations/addon/utils/cycle-breaker.js":"/**\n * Copyright 2016, Yahoo! Inc.\n * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\n/**\n * Use Ember Meta to break cycles in the CP chains. Lets say we have a User model with a `friends` property that is a hasMany\n * relationship. If we have a user John and he has a friend Jane, that creates a two-way relationship. John is Jane's friends and vise\n * versa. If we were to go down the CP chain and get validations for John's friends, it would go to Jane, then to Jane's friends, which\n * would point back to John. This method tracks which models have been already visited and breaks the cycle.\n */\n\nimport MetaData from './meta-data';\n\nexport default function cycleBreaker(fn, value) {\n  let key = MetaData.symbol('cycle');\n\n  return function() {\n    if (MetaData.getData(this, key)) {\n      return value;\n    }\n    MetaData.setData(this, key, true);\n    try {\n      return fn.apply(this, arguments);\n    } finally {\n      MetaData.setData(this, key, false);\n    }\n  };\n}\n","/home/travis/build/npmtest/node-npmtest-ember-cp-validations/node_modules/ember-cp-validations/addon/utils/flatten.js":"/**\n * Copyright 2016, Yahoo! Inc.\n * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\nexport default function flatten(array = []) {\n  let result = [];\n\n  for (let i = 0, l = array.length; i < l; i++) {\n    let item = array[i];\n\n    if (Array.isArray(item)) {\n      result = result.concat(flatten(item));\n    } else {\n      result.push(item);\n    }\n  }\n\n  return result;\n}\n","/home/travis/build/npmtest/node-npmtest-ember-cp-validations/node_modules/ember-cp-validations/addon/utils/meta-data.js":"/**\n * Copyright 2016, Yahoo! Inc.\n * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\nimport Ember from 'ember';\n\nlet id = 0;\nconst dataKey = symbol('data');\n\nfunction symbol(key) {\n  return `_${key}_${new Date().getTime()}_${id++}`;\n}\n\nfunction getData(obj, s) {\n  let m = Ember.meta(obj);\n  let data = m[dataKey];\n\n  if (data) {\n    return data[s];\n  }\n}\n\nfunction setData(obj, s, value) {\n  let m = Ember.meta(obj);\n  let data = m[dataKey] = m[dataKey] || {};\n\n  data[s] = value;\n}\n\nexport default { symbol, getData, setData };\n","/home/travis/build/npmtest/node-npmtest-ember-cp-validations/node_modules/ember-cp-validations/addon/utils/should-call-super.js":"/**\n * Copyright 2016, Yahoo! Inc.\n * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\n/**\n * Checks if the give key exists on the object's super.\n * If so, we can successfully call the obj[key] _super\n *\n * Created by @rwjblue\n */\nexport default function shouldCallSuper(obj, key) {\n  let current = Object.getPrototypeOf(obj);\n  current = Object.getPrototypeOf(current);\n\n  while (current) {\n    let descriptor = Object.getOwnPropertyDescriptor(current, key);\n\n    if (descriptor) {\n      return true;\n    }\n\n    current = Object.getPrototypeOf(current);\n  }\n\n  return false;\n}\n","/home/travis/build/npmtest/node-npmtest-ember-cp-validations/node_modules/ember-cp-validations/addon/utils/utils.js":"/**\n * Copyright 2016, Yahoo! Inc.\n * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\nimport Ember from 'ember';\nimport requireModule from 'ember-require-module';\n\nconst DS = requireModule('ember-data');\n\nconst {\n  get,\n  typeOf,\n  isArray,\n  canInvoke,\n  A: emberArray\n} = Ember;\n\nconst { isHTMLSafe } = Ember.String;\n\nconst assign = Ember.assign || Ember.merge;\n\nexport function unwrapString(s) {\n  if (isHTMLSafe(s)) {\n    return s.toString();\n  }\n\n  return s;\n}\n\nexport function unwrapProxy(o) {\n  return isProxy(o) ? unwrapProxy(get(o, 'content')) : o;\n}\n\nexport function isProxy(o) {\n  return !!(o && (o instanceof Ember.ObjectProxy || o instanceof Ember.ArrayProxy));\n}\n\nexport function isPromise(p) {\n  return !!(p && canInvoke(p, 'then'));\n}\n\nexport function isDsModel(o) {\n  return !!(DS && o && o instanceof DS.Model);\n}\n\nexport function isDSManyArray(o) {\n  return !!(DS && o && isArray(o) && (o instanceof DS.PromiseManyArray || o instanceof DS.ManyArray));\n}\n\nexport function isEmberObject(o) {\n  return !!(o && o instanceof Ember.Object);\n}\n\nexport function isObject(o) {\n  return typeOf(o) === 'object' || typeOf(o) === 'instance';\n}\n\nexport function isDescriptor(o) {\n  return o && typeof o === 'object' && o.isDescriptor;\n}\n\nexport function isValidatable(value) {\n  let v = unwrapProxy(value);\n  return isDsModel(v) ? !get(v, 'isDeleted') : true;\n}\n\nexport function getValidatableValue(value) {\n  if (!value) {\n    return value;\n  }\n\n  if (isDSManyArray(value)) {\n    return emberArray(value.filter((v) => isValidatable(v)));\n  }\n\n  return isValidatable(value) ? value : undefined;\n}\n\nexport function mergeOptions(...options) {\n  let o = {};\n\n  for (let i = options.length - 1; i >= 0; i--) {\n    let _o = options[i];\n    assign(o, isObject(_o) ? _o : {});\n  }\n\n  return o;\n}\n","/home/travis/build/npmtest/node-npmtest-ember-cp-validations/node_modules/ember-cp-validations/addon/validations/error.js":"import Ember from 'ember';\n\n/**\n * @module Validations\n * @class Error\n */\n\nexport default Ember.Object.extend({\n  /**\n   * The error validator type\n   * @property type\n   * @type {String}\n   */\n  type: null,\n\n  /**\n   * The error message\n   * @property message\n   * @type {String}\n   */\n  message: null,\n\n  /**\n   * The attribute that the error belongs to\n   * @property attribute\n   * @type {String}\n   */\n  attribute: null,\n\n  /**\n   * The parent attribute that the error belongs to\n   * @property parentAttribute\n   * @type {String}\n   */\n  parentAttribute: null\n});\n","/home/travis/build/npmtest/node-npmtest-ember-cp-validations/node_modules/ember-cp-validations/addon/validations/factory.js":"/**\n * Copyright 2016, Yahoo! Inc.\n * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\nimport Ember from 'ember';\nimport flatten from '../utils/flatten';\nimport assign from '../utils/assign';\nimport ValidationResult from '../-private/result';\nimport ResultCollection from './result-collection';\nimport BaseValidator from '../validators/base';\nimport cycleBreaker from '../utils/cycle-breaker';\nimport shouldCallSuper from '../utils/should-call-super';\nimport { isDsModel, isValidatable, isPromise, isDescriptor, mergeOptions } from '../utils/utils';\n\nconst {\n  get,\n  set,\n  run,\n  RSVP,\n  isNone,\n  guidFor,\n  isEmpty,\n  isArray,\n  computed,\n  getOwner,\n  makeArray,\n  getWithDefault,\n  A: emberArray\n} = Ember;\n\nconst merge = Ember.assign || Ember.merge;\n\nconst {\n  Promise\n} = RSVP;\n\n/**\n * ## Running Manual Validations\n *\n * Although validations are lazily computed, there are times where we might want to force all or\n * specific validations to happen. For this reason we have exposed three methods:\n *\n * - {{#crossLink \"Factory/validate:method\"}}{{/crossLink}}: Will always return a promise and should be used if asynchronous validations are present\n * - {{#crossLink \"Factory/validateSync:method\"}}{{/crossLink}}: Should only be used if all validations are synchronous. It will throw an error if any of the validations are asynchronous\n * - {{#crossLink \"Factory/validateAttribute:method\"}}{{/crossLink}}: A functional approach to validating an attribute without changing its state\n *\n * @module Validations\n * @main Validations\n */\n\n/**\n * All validations can be accessed via the `validations` object created on your model/object.\n * Each attribute also has its own validation which has the same properties.\n * An attribute validation can be accessed via `validations.attrs.<ATTRIBUTE>` which will return a {{#crossLink \"ResultCollection\"}}{{/crossLink}}.\n *\n * ### Global Validations\n *\n * Global validations exist on the `validations` object that resides on the object that is being validated.\n * To see all possible properties, please checkout the docs for {{#crossLink \"ResultCollection\"}}{{/crossLink}}.\n *\n * ```js\n * model.get('validations.isValid');\n * model.get('validations.errors');\n * model.get('validations.messages');\n * // etc...\n * ```\n *\n * ### Attribute Validations\n *\n * The `validations` object also contains an `attrs` object which holds a {{#crossLink \"ResultCollection\"}}{{/crossLink}}\n * for each attribute specified in your validation rules.\n *\n * ```js\n * model.get('validations.attrs.username.isValid');\n * model.get('validations.attrs.password.errors');\n * model.get('validations.attrs.email.messages');\n * // etc...\n * ```\n * @module Validations\n * @submodule Accessing Validations\n */\n\n/**\n * @module Validations\n * @class Factory\n */\n\n/**\n * Top level method that will ultimately return a mixin with all CP validations\n *\n * @method  buildValidations\n * @param  {Object} validations  Validation rules\n * @return {Ember.Mixin}\n */\nexport default function buildValidations(validations = {}, globalOptions = {}) {\n  normalizeOptions(validations, globalOptions);\n\n  let Validations, validationMixinCount;\n\n  let ValidationsMixin = Ember.Mixin.create({\n    init() {\n      this._super(...arguments);\n\n      // Count number of mixins to bypass super check if there is more than 1\n      this.__validationsMixinCount__ = this.__validationsMixinCount__ || 0;\n      validationMixinCount = ++this.__validationsMixinCount__;\n    },\n    __validationsClass__: computed(function() {\n      if (!Validations) {\n        let inheritedClass;\n\n        if (shouldCallSuper(this, '__validationsClass__') || validationMixinCount > 1) {\n          inheritedClass = this._super();\n        }\n\n        Validations = createValidationsClass(inheritedClass, validations, this);\n      }\n      return Validations;\n    }).readOnly(),\n\n    validations: computed(function() {\n      return this.get('__validationsClass__').create({ model: this });\n    }).readOnly(),\n\n    validate() {\n      return get(this, 'validations').validate(...arguments);\n    },\n\n    validateSync() {\n      return get(this, 'validations').validateSync(...arguments);\n    },\n\n    validateAttribute() {\n      return get(this, 'validations').validateAttribute(...arguments);\n    },\n\n    destroy() {\n      this._super(...arguments);\n      get(this, 'validations').destroy();\n    }\n  });\n\n  // Label mixin under a named scope for Ember Inspector\n  ValidationsMixin[Ember.NAME_KEY] = 'Validations';\n\n  return ValidationsMixin;\n}\n\n/**\n * Validation rules can be created with default and global options\n * {\n *   description: 'Username',\n *   validators: [...]\n * }\n *\n * This method generate the default options pojo, applies it to each validation rule, and flattens the object\n *\n * @method normalizeOptions\n * @private\n * @param  {Object} validations\n * @return\n */\nfunction normalizeOptions(validations = {}, globalOptions = {}) {\n  let validatableAttrs = Object.keys(validations);\n\n  validatableAttrs.forEach((attribute) => {\n    let rules = validations[attribute];\n\n    if (rules && typeof rules === 'object' && isArray(rules.validators)) {\n      let options = Object.keys(rules).reduce((o, k) => {\n        if (k !== 'validators') {\n          o[k] = rules[k];\n        }\n        return o;\n      }, {});\n\n      let { validators } = rules;\n      validators.forEach((v) => {\n        v.defaultOptions = options;\n      });\n      validations[attribute] = validators;\n    }\n    validations[attribute] = makeArray(validations[attribute]);\n    validations[attribute].forEach((v) => {\n      v.globalOptions = globalOptions;\n    });\n  });\n}\n\n/**\n * Creates the validations class that will become `model.validations`.\n *   - Setup parent validation inheritance\n *   - Normalize nested keys (i.e. 'details.dob') into objects (i.e { details: { dob: validator() }})\n *   - Merge normalized validations with parent\n *   - Create global CPs (i.e. 'isValid', 'messages', etc...)\n *\n * @method createValidationsClass\n * @private\n * @param  {Object} inheritedValidationsClass\n * @param  {Object} validations\n * @param  {Object} model\n * @return {Ember.Object}\n */\nfunction createValidationsClass(inheritedValidationsClass, validations, model) {\n  let validationRules = {};\n  let validatableAttributes = Object.keys(validations);\n\n  // Setup validation inheritance\n  if (inheritedValidationsClass && inheritedValidationsClass.__isCPValidationsClass__) {\n    let inheritedValidations = inheritedValidationsClass.create();\n\n    validationRules = merge(validationRules, inheritedValidations.get('_validationRules'));\n    validatableAttributes = emberArray(inheritedValidations.get('validatableAttributes').concat(validatableAttributes)).uniq();\n  }\n\n  // Normalize nested keys into actual objects and merge them with parent object\n  Object.keys(validations).reduce((obj, key) => {\n    assign(obj, key, validations[key]);\n    return obj;\n  }, validationRules);\n\n  // Create the mixin that holds all the top level validation props (isValid, messages, etc)\n  let TopLevelProps = createTopLevelPropsMixin(validatableAttributes);\n\n  // Create the `attrs` class which will add the current model reference once instantiated\n  let AttrsClass = createAttrsClass(validatableAttributes, validationRules, model);\n\n  // Create `validations` class\n  let ValidationsClass = Ember.Object.extend(TopLevelProps, {\n    model: null,\n    attrs: null,\n    isValidations: true,\n\n    validatableAttributes: computed(function() {\n      return validatableAttributes;\n    }).readOnly(),\n\n    // Caches\n    _validators: null,\n    _debouncedValidations: null,\n\n    // Private\n    _validationRules: computed(function() {\n      return validationRules;\n    }).readOnly(),\n\n    validate,\n    validateSync,\n    validateAttribute,\n\n    init() {\n      this._super(...arguments);\n      this.setProperties({\n        attrs: AttrsClass.create({\n          _model: this.get('model')\n        }),\n        _validators: {},\n        _debouncedValidations: {}\n      });\n    },\n\n    destroy() {\n      this._super(...arguments);\n      let validatableAttrs = get(this, 'validatableAttributes');\n      let debouncedValidations = get(this, '_debouncedValidations');\n\n      // Initiate attrs destroy to cleanup any remaining model references\n      this.get('attrs').destroy();\n\n      // Cancel all debounced timers\n      validatableAttrs.forEach((attr) => {\n        let attrCache = get(debouncedValidations, attr);\n\n        if (!isNone(attrCache)) {\n          // Itterate over each attribute and cancel all of its debounced validations\n          Object.keys(attrCache).forEach((v) => run.cancel(attrCache[v]));\n        }\n      });\n    }\n  });\n\n  ValidationsClass.reopenClass({\n    __isCPValidationsClass__: true\n  });\n\n  return ValidationsClass;\n}\n\n/**\n * Creates the `attrs` class which holds all the CP logic\n *\n * ```javascript\n * model.get('validations.attrs.username');\n * model.get('validations.attrs.nested.object.attribute');\n * ```\n *\n * @method createAttrsClass\n * @private\n * @param  {Object} validatableAttributes\n * @param  {Object} validationRules\n * @param  {Object} model\n * @return {Ember.Object}\n */\nfunction createAttrsClass(validatableAttributes, validationRules, model) {\n  let nestedClasses = {};\n  let rootPath = 'root';\n\n  let AttrsClass = Ember.Object.extend({\n    __path__: rootPath,\n\n    init() {\n      this._super(...arguments);\n\n      let _model = this.get('_model');\n      let path = this.get('__path__');\n\n      /*\n        Instantiate the nested attrs classes for the current path\n       */\n      Object.keys(nestedClasses[path] || []).forEach((key) => {\n        set(this, key, nestedClasses[path][key].create({\n          _model\n        }));\n      });\n    },\n\n    destroy() {\n      this._super(...arguments);\n\n      let path = this.get('__path__');\n\n      /*\n        Remove the model reference from each nested class and destroy it\n       */\n      Object.keys(nestedClasses[path] || []).forEach((key) => {\n        let o = get(this, key);\n        o.set('_model', null);\n        o.destroy();\n      });\n    }\n  });\n\n  /*\n    Insert CPs + Create nested classes\n   */\n  validatableAttributes.forEach((attribute) => {\n    let path = attribute.split('.');\n    let attr = path.pop();\n    let currPath = [rootPath];\n    let currClass = AttrsClass;\n\n    // Iterate over the path and create the necessary nested classes along the way\n    for (let i = 0; i < path.length; i++) {\n      let key = path[i];\n      let currPathStr = currPath.join('.');\n      let _nestedClasses;\n\n      nestedClasses[currPathStr] = nestedClasses[currPathStr] || {};\n      _nestedClasses = nestedClasses[currPathStr];\n\n      currPath.push(key);\n\n      if (!_nestedClasses[key]) {\n        _nestedClasses[key] = AttrsClass.extend({\n          __path__: currPath.join('.')\n        });\n      }\n\n      currClass = _nestedClasses[key];\n    }\n\n    // Add the final attr's CP to the class\n    currClass.reopen({\n      [attr]: createCPValidationFor(attribute, model, get(validationRules, attribute))\n    });\n  });\n\n  return AttrsClass;\n}\n\n/**\n * CP generator for the given attribute\n *\n * @method createCPValidationFor\n * @private\n * @param  {String} attribute\n * @param  {Object} model         Since the CPs are created once per class on the first initialization,\n *                                this is the first model that was instantiated\n * @param  {Array} validations\n * @return {Ember.ComputedProperty} A computed property which is a ResultCollection\n */\nfunction createCPValidationFor(attribute, model, validations) {\n  let isVolatile = hasOption(validations, 'volatile', true);\n  let dependentKeys = isVolatile ? [] : getCPDependentKeysFor(attribute, model, validations);\n\n  let cp = computed(...dependentKeys, cycleBreaker(function() {\n    let model = get(this, '_model');\n    let validators = !isNone(model) ? getValidatorsFor(attribute, model) : [];\n\n    let validationResults = generateValidationResultsFor(attribute, model, validators, (validator, options) => {\n      return validator.validate(validator.getValue(), options, model, attribute);\n    });\n\n    return ResultCollection.create({\n      attribute,\n      content: validationResults\n    });\n  })).readOnly();\n\n  if (isVolatile) {\n    cp = cp.volatile();\n  }\n\n  return cp;\n}\n\n/**\n * Check if a collection of validations have an option\n * equal to the given value\n *\n * @method hasOption\n * @private\n * @param {Array} validations\n * @param {String} option\n * @param {Boolean} [value=true]\n * @returns {Boolean}\n */\nfunction hasOption(validations, option, value = true) {\n  for (let i = 0; i < validations.length; i++) {\n    let { options, defaultOptions = {}, globalOptions = {} } = validations[i];\n    let mergedOptions = mergeOptions(options, defaultOptions, globalOptions);\n\n    if (mergedOptions[option] === value) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Generates the validation results for a given attribute and validators. If a\n * given validator should be validated, it calls upon the validate callback to retrieve\n * the result.\n *\n * @method generateValidationResultsFor\n * @private\n * @param  {String} attribute\n * @param  {Object} model\n * @param  {Array} validators\n * @param  {Function} validate\n * @param  {Object} opts\n *                    - disableDebounceCache {Boolean}\n * @return {Array}\n */\nfunction generateValidationResultsFor(attribute, model, validators, validate, opts = {}) {\n  let isModelValidatable = isValidatable(model);\n  let isInvalid = false;\n  let value, result;\n\n  return validators.map((validator) => {\n    let options = get(validator, 'options').copy();\n    let isWarning = getWithDefault(options, 'isWarning', false);\n    let disabled = getWithDefault(options, 'disabled', false);\n    let debounce = getWithDefault(options, 'debounce', 0);\n    let lazy = getWithDefault(options, 'lazy', true);\n\n    if (disabled || (lazy && isInvalid) || !isModelValidatable) {\n      value = true;\n    } else if (debounce > 0) {\n      let cache = getDebouncedValidationsCacheFor(attribute, model);\n\n      // Return a promise and pass the resolve method to the debounce handler\n      value = new Promise((resolve) => {\n        let t = run.debounce(validator, resolveDebounce, resolve, debounce);\n\n        if (!opts.disableDebounceCache) {\n          cache[guidFor(validator)] = t;\n        }\n      }).then(() => {\n        return validate(validator, get(validator, 'options').copy());\n      });\n    } else {\n      value = validate(validator, options);\n    }\n\n    result = validationReturnValueHandler(attribute, value, model, validator);\n\n    /*\n      If the current result is invalid, the rest of the validations do not need to be\n      triggered (if lazy) since the attribute is already in an invalid state.\n     */\n    if (!isInvalid && !isWarning && get(result, 'isInvalid')) {\n      isInvalid = true;\n    }\n\n    return result;\n  });\n}\n\n/**\n * Create a mixin that will have all the top level CPs under the validations object.\n * These are computed collections on different properties of each attribute validations CP\n *\n * @method createTopLevelPropsMixin\n * @private\n * @param  {Object} validations\n */\nfunction createTopLevelPropsMixin(validatableAttrs) {\n  // Expose the following properties as public APIs via readOnly aliases\n  let aliases = [\n    'isWarning',\n    'isValid',\n    'isValidating',\n    'isDirty',\n    'isAsync',\n    'isNotValidating',\n    'isInvalid',\n    'isTruelyValid',\n    'messages',\n    'message',\n    'warningMessages',\n    'warningMessage',\n    'warnings',\n    'warning',\n    'errors',\n    'error',\n    '_promise'\n  ];\n\n  let topLevelProps = aliases.reduce((props, alias) => {\n    props[alias] = computed.readOnly(`__attrsResultCollection__.${alias}`);\n    return props;\n  }, {});\n\n  return Ember.Mixin.create(topLevelProps, {\n    /*\n      Dedupe logic by creating a top level ResultCollection for all attr's ResultCollections\n     */\n    __attrsResultCollection__: computed(...validatableAttrs.map((attr) => `attrs.${attr}`), function() {\n      return ResultCollection.create({\n        content: validatableAttrs.map((attr) => get(this, `attrs.${attr}`))\n      });\n    }).readOnly()\n  });\n}\n\n/**\n * CP dependency generator for a give attribute depending on its relationships\n *\n * @method getCPDependentKeysFor\n * @private\n * @param  {String} attribute\n * @param  {Object} model         Since the CPs are created once per class on the first initialization,\n *                                this is the first model that was instantiated\n * @param  {Array} validations\n * @return {Array} Unique list of dependencies\n */\nfunction getCPDependentKeysFor(attribute, model, validations) {\n  let owner = getOwner(model);\n\n  let dependentKeys = validations.map((validation) => {\n    let { options } = validation;\n    let type = validation._type;\n    let Validator = type === 'function' ? BaseValidator : lookupValidator(owner, type).class;\n    let baseDependents = BaseValidator.getDependentsFor(attribute, options) || [];\n    let dependents = Validator.getDependentsFor(attribute, options) || [];\n\n    return [\n      ...baseDependents,\n      ...dependents,\n\n      // Get all explicitly defined dependents\n      ...getWithDefault(options, 'dependentKeys', []),\n      ...getWithDefault(validation, 'defaultOptions.dependentKeys', []),\n      ...getWithDefault(validation, 'globalOptions.dependentKeys', []),\n\n      // Extract implicit dependents from CPs\n      ...extractOptionsDependentKeys(options),\n      ...extractOptionsDependentKeys(get(validation, 'defaultOptions')),\n      ...extractOptionsDependentKeys(get(validation, 'globalOptions'))\n    ];\n  });\n\n  dependentKeys = flatten(dependentKeys);\n\n  dependentKeys.push(`model.${attribute}`);\n\n  if (isDsModel(model)) {\n    dependentKeys.push('model.isDeleted');\n  }\n\n  dependentKeys = dependentKeys.map((d) => {\n    return `${d.split('.')[0] === 'model' ? '_' : ''}${d}`;\n  });\n\n  return emberArray(dependentKeys).uniq();\n}\n\n/**\n * Extract all dependentKeys from any property that is a CP\n *\n * @method extractOptionsDependentKeys\n * @private\n * @param  {Object} options\n * @return {Array}  dependentKeys\n */\nfunction extractOptionsDependentKeys(options) {\n  if (options && typeof options === 'object') {\n    return Object.keys(options).reduce((arr, key) => {\n      let option = options[key];\n\n      if (isDescriptor(option)) {\n        return arr.concat(option._dependentKeys || []);\n      }\n\n      return arr;\n    }, []);\n  }\n\n  return [];\n}\n\n/**\n * A handler used to create ValidationResult object from values returned from a validator\n *\n * @method validationReturnValueHandler\n * @private\n * @param  {String} attribute\n * @param  {Mixed} value\n * @param  {Object} model\n * @return {ValidationResult}\n */\nfunction validationReturnValueHandler(attribute, value, model, validator) {\n  let result;\n  let commonProps = {\n    model,\n    attribute,\n    _validator: validator\n  };\n\n  if (isPromise(value)) {\n    result = ValidationResult.create(commonProps, {\n      _promise: Promise.resolve(value)\n    });\n  } else {\n    result = ValidationResult.create(commonProps);\n    result.update(value);\n  }\n\n  return result;\n}\n\n/**\n * Get validators for the give attribute. If they are not in the cache, then create them.\n *\n * @method getValidatorsFor\n * @private\n * @param  {String} attribute\n * @param  {Object} model\n * @return {Array}\n */\nfunction getValidatorsFor(attribute, model) {\n  let validators = get(model, `validations._validators.${attribute}`);\n  return isNone(validators) ? createValidatorsFor(attribute, model) : validators;\n}\n\n/**\n * Get debounced validation cache for the given attribute. If it doesn't exist, create a new one.\n *\n * @method getValidatorCacheFor\n * @private\n * @param  {String} attribute\n * @param  {Object} model\n * @return {Map}\n */\nfunction getDebouncedValidationsCacheFor(attribute, model) {\n  let debouncedValidations = get(model, 'validations._debouncedValidations');\n\n  if (isNone(get(debouncedValidations, attribute))) {\n    assign(debouncedValidations, attribute, {});\n  }\n\n  return get(debouncedValidations, attribute);\n}\n\n/**\n * Create validators for the give attribute and store them in a cache\n *\n * @method createValidatorsFor\n * @private\n * @param  {String} attribute\n * @param  {Object} model\n * @return {Array}\n */\nfunction createValidatorsFor(attribute, model) {\n  let validations = get(model, 'validations');\n  let validationRules = makeArray(get(validations, `_validationRules.${attribute}`));\n  let validatorCache = get(validations, '_validators');\n  let owner = getOwner(model);\n  let validators = [];\n  let validator;\n\n  // We must have an owner to be able to lookup our validators\n  if (isNone(owner)) {\n    throw new TypeError(`[ember-cp-validations] ${model.toString()} is missing a container or owner.`);\n  }\n\n  validationRules.forEach((v) => {\n    v.attribute = attribute;\n    v.model = model;\n\n    // If validate function exists, that means validator was created with a function so use the base class\n    if (v._type === 'function') {\n      validator = BaseValidator.create(owner.ownerInjection(), v);\n    } else {\n      validator = lookupValidator(owner, v._type).create(v);\n    }\n\n    validators.push(validator);\n  });\n\n  // Add validators to model instance cache\n  assign(validatorCache, attribute, validators);\n\n  return validators;\n}\n\n/**\n * Lookup a validators of a specific type on the owner\n *\n * @method lookupValidator\n * @throws {Error} Validator not found\n * @private\n * @param  {Ember.Owner} owner\n * @param  {String} type\n * @return {Class} Validator class or undefined if not found\n */\nfunction lookupValidator(owner, type) {\n  let validatorClass = owner.factoryFor(`validator:${type}`);\n\n  if (isNone(validatorClass)) {\n    throw new Error(`[ember-cp-validations] Validator not found of type: ${type}.`);\n  }\n\n  return validatorClass;\n}\n\n/**\n * Call the passed resolve method. This is needed as run.debounce expects a\n * static method to work properly.\n *\n * @method resolveDebounce\n * @private\n * @param  {Function} resolve\n */\nfunction resolveDebounce(resolve)  {\n  resolve();\n}\n\n/**\n * ```javascript\n * model.validate({ on: ['username', 'email'] }).then(({ m, validations }) => {\n *   validations.get('isValid'); // true or false\n *   validations.get('isValidating'); // false\n *\n *   let usernameValidations = m.get('validations.attrs.username');\n *   usernameValidations.get('isValid') // true or false\n * });\n * ```\n *\n * @method validate\n * @param  {Object} options\n * @param  {Array} options.on Only validate the given attributes. If empty, will validate over all validatable attribute\n * @param  {Array} options.excludes Exclude validation on the given attributes\n * @param  {Boolean} async      If `false`, will get all validations and will error if an async validations is found.\n *                              If `true`, will get all validations and wrap them in a promise hash\n * @return {Promise or Object}  Promise if async is true, object if async is false\n */\nfunction validate(options = {}, async = true) {\n  let model = get(this, 'model');\n  let whiteList = makeArray(options.on);\n  let blackList = makeArray(options.excludes);\n\n  let validationResults = get(this, 'validatableAttributes').reduce((v, name) => {\n    if (!isEmpty(blackList) && blackList.indexOf(name) !== -1) {\n      return v;\n    }\n\n    if (isEmpty(whiteList) || whiteList.indexOf(name) !== -1) {\n      let validationResult = get(this, `attrs.${name}`);\n\n      // If an async validation is found, throw an error\n      if (!async && get(validationResult, 'isAsync')) {\n        throw new Error(`[ember-cp-validations] Synchronous validation failed due to ${name} being an async validation.`);\n      }\n\n      v.push(validationResult);\n    }\n\n    return v;\n  }, []);\n\n  let validations = ResultCollection.create({\n    content: validationResults\n  });\n\n  let resultObject = { model, validations };\n\n  if (async) {\n    if (get(validations, 'isAsync')) {\n      return RSVP.allSettled(makeArray(get(validations, '_promise'))).then(() => resultObject);\n    }\n\n    return Promise.resolve(resultObject);\n  }\n\n  return resultObject;\n}\n\n/**\n * A functional approach to check if a given attribute on a model is valid independently of the\n * model attribute's validations. This method will always return a promise which will then resolve\n * to a {{#crossLink \"ResultCollection\"}}{{/crossLink}}.\n *\n * ```javascript\n * model.validateAttribute('username', 'offirgolan').then(({ m, validations }) => {\n *   validations.get('isValid'); // true or false\n *   validations.get('isValidating'); // false\n * });\n * ```\n *\n * @method validateAttribute\n * @param  {String}   attribute\n * @param  {Mixed}  value\n * @return {Promise}\n * @async\n */\nfunction validateAttribute(attribute, value) {\n  let model = get(this, 'model');\n  let validators = !isNone(model) ? getValidatorsFor(attribute, model) : [];\n\n  let validationResults = generateValidationResultsFor(attribute, model, validators, (validator, options) => {\n    return validator.validate(value, options, model, attribute);\n  }, {\n    disableDebounceCache: true\n  });\n\n  let validations = ResultCollection.create({\n    attribute,\n    content: flatten(validationResults)\n  });\n\n  let result = { model, validations };\n\n  return Promise.resolve(get(validations, 'isAsync') ? get(validations, '_promise').then(() => result) : result);\n}\n\n/**\n * ```javascript\n * let { m, validations } = model.validateSync();\n * validations.get('isValid') // true or false\n * ```\n *\n * @method validateSync\n * @param  {Object}  options\n * @param  {Array} options.on Only validate the given attributes. If empty, will validate over all validatable attribute\n * @param  {Array} options.excludes Exclude validation on the given attributes\n * @return {Object}\n */\nfunction validateSync(options) {\n  return this.validate(options, false);\n}\n","/home/travis/build/npmtest/node-npmtest-ember-cp-validations/node_modules/ember-cp-validations/addon/validations/result-collection.js":"/**\n * Copyright 2016, Yahoo! Inc.\n * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\nimport Ember from 'ember';\nimport flatten from '../utils/flatten';\nimport cycleBreaker from '../utils/cycle-breaker';\n\nconst {\n  get,\n  set,\n  RSVP,\n  computed,\n  isArray,\n  isNone,\n  A: emberArray\n} = Ember;\n\nconst A = emberArray();\n\nfunction callable(method) {\n  return function(collection) {\n    return A[method].apply(collection, arguments);\n  };\n}\n\nconst uniq = callable('uniq');\nconst compact = callable('compact');\n\n/*\n  CP Macros\n */\nfunction isAny(collection, key, value, defaultValue) {\n  return computed(`${collection}.@each.${key}`, cycleBreaker(function() {\n    return get(this, collection).isAny(key, value);\n  }, defaultValue));\n}\n\nfunction isEvery(collection, key, value, defaultValue) {\n  return computed(`${collection}.@each.${key}`, cycleBreaker(function() {\n    return get(this, collection).isEvery(key, value);\n  }, defaultValue));\n}\n\n/**\n * @module Validations\n * @class ResultCollection\n */\nexport default Ember.ArrayProxy.extend({\n\n  init() {\n    set(this, 'content', emberArray(compact(get(this, 'content'))));\n    this._super(...arguments);\n  },\n\n  /**\n   * The attribute that this collection belongs to\n   *\n   * @property attribute\n   * @type {String}\n   */\n  attribute: null,\n\n  /**\n   * ```javascript\n   * // Examples\n   * get(user, 'validations.isWarning')\n   * get(user, 'validations.attrs.username.isWarning')\n   * ```\n   *\n   * @property isWarning\n   * @default false\n   * @readOnly\n   * @type {Boolean}\n   */\n  isWarning: isEvery('content', 'isWarning', true, false).readOnly(),\n\n  /**\n   * ```javascript\n   * // Examples\n   * get(user, 'validations.isInvalid')\n   * get(user, 'validations.attrs.username.isInvalid')\n   * ```\n   *\n   * @property isInvalid\n   * @default false\n   * @readOnly\n   * @type {Boolean}\n   */\n  isInvalid: computed.not('isValid').readOnly(),\n\n  /**\n   * ```javascript\n   * // Examples\n   * get(user, 'validations.isValid')\n   * get(user, 'validations.attrs.username.isValid')\n   * ```\n   *\n   * @property isValid\n   * @default true\n   * @readOnly\n   * @type {Boolean}\n   */\n  isValid: isEvery('_errorContent', 'isValid', true, true).readOnly(),\n\n  /**\n   * This property is toggled only if there is an async validation\n   *\n   * ```javascript\n   * // Examples\n   * get(user, 'validations.isValidating')\n   * get(user, 'validations.attrs.username.isValidating')\n   * ```\n   *\n   * @property isValidating\n   * @default false\n   * @readOnly\n   * @type {Boolean}\n   */\n  isValidating: isAny('content', 'isValidating', true, false).readOnly(),\n\n  /**\n   * Will be true only if isValid is `true` and isValidating is `false`\n   *\n   * ```javascript\n   * // Examples\n   * get(user, 'validations.isTruelyValid')\n   * get(user, 'validations.attrs.username.isTruelyValid')\n   * ```\n   *\n   * @property isTruelyValid\n   * @default true\n   * @readOnly\n   * @type {Boolean}\n   */\n  isTruelyValid: isEvery('_errorContent', 'isTruelyValid', true, true).readOnly(),\n\n  /**\n   * Will be true is the attribute in question is not `null` or `undefined`. If the object being\n   * validated is an Ember Data Model and you have a `defaultValue` specified, then it will use that for comparison.\n   *\n   * ```javascript\n   * // Examples\n   * // 'username' : DS.attr('string', { defaultValue: 'johndoe' })\n   * get(user, 'validations.isDirty')\n   * get(user, 'validations.attrs.username.isDirty')\n   * ```\n   *\n   * @property isDirty\n   * @default false\n   * @readOnly\n   * @type {Boolean}\n   */\n  isDirty: isAny('_errorContent', 'isDirty', true, false).readOnly(),\n\n  /**\n   * Will be `true` only if a validation returns a promise\n   *\n   * ```javascript\n   * // Examples\n   * get(user, 'validations.isAsync')\n   * get(user, 'validations.attrs.username.isAsync')\n   * ```\n   *\n   * @property isAsync\n   * @default false\n   * @readOnly\n   * @type {Boolean}\n   */\n  isAsync: isAny('content', 'isAsync', true, false).readOnly(),\n\n  /**\n   * A collection of all error messages on the object in question\n   *\n   * ```javascript\n   * // Examples\n   * get(user, 'validations.messages')\n   * get(user, 'validations.attrs.username.messages')\n   * ```\n   *\n   * @property messages\n   * @readOnly\n   * @type {Array}\n   */\n  messages: computed('_errorContent.@each.messages', cycleBreaker(function() {\n    let messages = flatten(get(this, '_errorContent').getEach('messages'));\n    return uniq(compact(messages));\n  })).readOnly(),\n\n  /**\n   * An alias to the first message in the messages collection.\n   *\n   * ```javascript\n   * // Example\n   * get(user, 'validations.message')\n   * get(user, 'validations.attrs.username.message')\n   * ```\n   *\n   * @property message\n   * @readOnly\n   * @type {String}\n   */\n  message: computed.readOnly('messages.firstObject'),\n\n  /**\n   * A collection of all warning messages on the object in question\n   *\n   * ```javascript\n   * // Examples\n   * get(user, 'validations.warningMessages')\n   * get(user, 'validations.attrs.username.warningMessages')\n   * ```\n   *\n   * @property warningMessages\n   * @readOnly\n   * @type {Array}\n   */\n  warningMessages: computed('_warningContent.@each.messages', cycleBreaker(function() {\n    let messages = flatten(get(this, '_warningContent').getEach('messages'));\n    return uniq(compact(messages));\n  })).readOnly(),\n\n  /**\n   * An alias to the first message in the warningMessages collection.\n   *\n   * ```javascript\n   * // Example\n   * get(user, 'validations.warningMessage')\n   * get(user, 'validations.attrs.username.warningMessage')\n   * ```\n   *\n   * @property warningMessage\n   * @readOnly\n   * @type {String}\n   */\n  warningMessage: computed.readOnly('warningMessages.firstObject'),\n\n  /**\n   * A collection of all {{#crossLink \"Error\"}}Warnings{{/crossLink}} on the object in question.\n   * Each warning object includes the warning message and it's associated attribute name.\n   *\n   * ```javascript\n   * // Example\n   * get(user, 'validations.warnings')\n   * get(user, 'validations.attrs.username.warnings')\n   * ```\n   *\n   * @property warnings\n   * @readOnly\n   * @type {Array}\n   */\n  warnings: computed('attribute', '_warningContent.@each.errors', cycleBreaker(function() {\n    return computeErrorCollection(get(this, 'attribute'), get(this, '_warningContent'));\n  })).readOnly(),\n\n  /**\n   * An alias to the first {{#crossLink \"Warning\"}}{{/crossLink}} in the warnings collection.\n   *\n   * ```javascript\n   * // Example\n   * get(user, 'validations.warning')\n   * get(user, 'validations.attrs.username.warning')\n   * ```\n   *\n   * @property warning\n   * @readOnly\n   * @type {Error}\n   */\n  warning: computed.readOnly('warnings.firstObject'),\n\n  /**\n   * A collection of all {{#crossLink \"Error\"}}Errors{{/crossLink}} on the object in question.\n   * Each error object includes the error message and it's associated attribute name.\n   *\n   * ```javascript\n   * // Example\n   * get(user, 'validations.errors')\n   * get(user, 'validations.attrs.username.errors')\n   * ```\n   *\n   * @property errors\n   * @readOnly\n   * @type {Array}\n   */\n  errors: computed('attribute', '_errorContent.@each.errors', cycleBreaker(function() {\n    return computeErrorCollection(get(this, 'attribute'), get(this, '_errorContent'));\n  })).readOnly(),\n\n  /**\n   * An alias to the first {{#crossLink \"Error\"}}{{/crossLink}} in the errors collection.\n   *\n   * ```javascript\n   * // Example\n   * get(user, 'validations.error')\n   * get(user, 'validations.attrs.username.error')\n   * ```\n   *\n   * @property error\n   * @readOnly\n   * @type {Error}\n   */\n  error: computed.readOnly('errors.firstObject'),\n\n  /**\n   * All built options of the validators associated with the results in this collection grouped by validator type\n   *\n   * ```javascript\n   * // Given the following validators\n   * {\n   *   username: [\n   *     validator('presence', true),\n   *     validator('length', { max: 15 }),\n   *     validator('format', { regex: /foo/ }),\n   *     validator('format', { regex: /bar/ }),\n   *   ]\n   * }\n   * ```\n   *\n   * ```js\n   * get(user, 'validations.attrs.username.options')\n   * ```\n   *\n   * The above will return the following\n   * ```js\n   * {\n   *   'presence': { presence: true},\n   *   'length': { max: 15 },\n   *   'regex': [{ regex: /foo/ }, { regex: /bar/ }]\n   * }\n   * ```\n   *\n   * @property options\n   * @readOnly\n   * @type {Object}\n   */\n  options: computed('_contentValidators.@each.options', function() {\n    return groupValidatorOptions(get(this, '_contentValidators'));\n  }).readOnly(),\n\n  /**\n   * @property _promise\n   * @async\n   * @private\n   * @type {Promise}\n   */\n  _promise: computed('content.@each._promise', cycleBreaker(function() {\n    return RSVP.allSettled(compact(flatten(this.getEach('_promise'))));\n  })).readOnly(),\n\n  /**\n   * @property _contentValidators\n   * @type {Array}\n   * @private\n   */\n  _contentValidators: computed.mapBy('_errorContent', '_validator').readOnly(),\n\n  /**\n   * @property _errorContent\n   * @type {Array}\n   * @private\n   */\n  _errorContent: computed.filterBy('content', 'isWarning', false).readOnly(),\n\n  /**\n   * @property _warningContent\n   * @type {Array}\n   * @private\n   */\n  _warningContent: computed.filterBy('content', 'isWarning', true).readOnly()\n});\n\nfunction computeErrorCollection(attribute, content = []) {\n  let errors = flatten(content.getEach('errors'));\n\n  errors = uniq(compact(errors));\n  errors.forEach((e) => {\n    if (attribute && e.get('attribute') !== attribute) {\n      e.set('parentAttribute', attribute);\n    }\n  });\n\n  return errors;\n}\n\n/**\n * Used by the `options` property to create a hash from the `content` that is grouped by validator type.\n * If there is more than 1 of a type, it groups it into an array of option objects.\n */\nfunction groupValidatorOptions(validators = []) {\n  return validators.reduce((options, v) => {\n    if (isNone(v) || isNone(get(v, '_type'))) {\n      return options;\n    }\n\n    let type = get(v, '_type');\n    let vOpts = get(v, 'options').copy();\n\n    if (options[type]) {\n      if (isArray(options[type])) {\n        options[type].push(vOpts);\n      } else {\n        options[type] = [options[type], vOpts];\n      }\n    } else {\n      options[type] = vOpts;\n    }\n    return options;\n  }, {});\n}\n","/home/travis/build/npmtest/node-npmtest-ember-cp-validations/node_modules/ember-cp-validations/addon/validations/validator.js":"/**\n * Copyright 2016, Yahoo! Inc.\n * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\nimport Ember from 'ember';\n\nconst {\n  isNone\n} = Ember;\n\n/**\n * @module Validators\n * @main Validators\n */\n\n/**\n * ### description\n *\n * Default: __'This field'__\n *\n * A descriptor for your attribute used in the error message strings.\n * You can overwrite this value in your `validators/messages.js` file by changing the `defaultDescription` property.\n *\n * ```javascript\n * // Examples\n * validator('date', {\n *   description: 'Date of birth'\n * })\n * // If validation is run and the attribute is empty, the error returned will be:\n * // 'Date of birth can't be blank'\n * ```\n *\n * ### lazy\n *\n * Default: __true__\n *\n * Only validate the given validator if the attribute is not already in an invalid\n * state. When you have multiple validators on an attribute, it will only validate subsequent\n * validators if the preceding validators have passed. When set to __false__, the validator\n * will always be executed, even if its preceding validators are invalid.\n *\n * ```javascript\n * // Examples\n * buildValidations({\n *  username: [\n *    validator('presence', true),\n *    validator('length', { min: 5 }),\n *    validator('custom-promise-based-validator') // Will only be executed if the above two have passed\n *  ]\n * });\n *\n * validator('custom-validator-that-must-executed', {\n *   lazy: false\n * })\n * ```\n *\n * ### dependentKeys\n *\n * A list of other model specific dependents for you validator.\n *\n * ```javascript\n * // Examples\n * validator('has-friends', {\n *   dependentKeys: ['model.friends.[]']\n * })\n * validator('has-valid-friends', {\n *   dependentKeys: ['model.friends.@each.username']\n * })\n * validator('x-validator', {\n *   dependentKeys: ['model.username', 'model.email', 'model.meta.foo.bar']\n * })\n * ```\n *\n * ### disabled\n *\n * Default: __false__\n *\n * If set to __true__, disables the given validator.\n *\n * ```js\n * // Examples\n * validator('presence', {\n *   presence: true,\n *   disabled: true\n * })\n * validator('presence', {\n *   presence: true,\n *   disabled: computed.not('model.shouldValidate')\n * })\n * ```\n *\n * ### debounce\n *\n * Default: __0__\n *\n * Debounces the validation with the given time in `milliseconds`. All debounced validations will\n * be handled asynchronously (wrapped in a promise).\n *\n * ```javascript\n * // Examples\n * validator('length', {\n *   debounce: 500\n * })\n * validator('x-validator', {\n *   debounce: 250\n * })\n * ```\n *\n * ### isWarning\n *\n * Default: __false__\n *\n * Any validator can be declared as a warning validator by setting `isWarning` to true. These validators will act as\n * assertions that when return a message, will be placed under `warnings` and `warningMessages` collections. What this means,\n * is that these validators will not have any affect on the valid state of the attribute allowing you to display warning messages\n * even when the attribute is valid.\n *\n * ```javascript\n * // Examples\n * validator('length', {\n *   isWarning: true,\n *   min: 6,\n *   message: 'Password is weak'\n * })\n * ```\n *\n * ### volatile\n *\n * Default: __false__\n *\n * If any validator sets the volatile option to **true** (including options, default options, and global options),\n * it will place the entire attribute's CP in a volatile state. This means that it will set it into non-cached mode.\n * When in this mode the computed property will not automatically cache the return value.\n *\n * Dependency keys have no effect on volatile properties as they are for cache invalidation and notification when\n * cached value is invalidated. Any changes to the dependents will not refire validations.\n *\n * __**WARNING: This option should only be used if you know what you're doing**__\n *\n * ```javascript\n * // Examples\n * validator('length', {\n *   volatile: true\n * })\n * ```\n *\n * ### value\n *\n * Used to retrieve the value to validate. This will overwrite the validator's default `value` method.\n * By default this returns `model[attribute]`. If you are dependent on other model attributes, you will\n * need to add them as `dependentKeys`.\n *\n * ```javascript\n * // Examples\n * validator('date', {\n *   value(model, attribute) {\n *   \t// Format the original value before passing it into the validator\n *   \treturn moment().utc(model.get(attribute)).format('DD/MM/YYY');\n *   }\n * })\n * validator('number', {\n *   dependentKeys: ['someOtherAttr'],\n *   value(model, attribute) {\n *    // Validate a value that is not the current attribute\n *    return this.get('model').get('someOtherAttr');\n *   }\n * })\n * ```\n *\n * ### message\n *\n * This option can take two forms. It can either be a `string` (a CP that returns a string is also valid), or a `function`.\n * If a string is used, then it will overwrite all error message types for the specified validator.\n *\n * ```javascript\n * // Example: String\n * validator('confirmation', {\n *   message: 'Email does not match {attribute}. What are you even thinking?!'\n * })\n * ```\n *\n * We can pass a `function` into our message option for even more customization capabilities.\n *\n * ```javascript\n * // Example: Function\n * validator('date', {\n *   message(type, options, value, context) {\n *     if (type === 'before') {\n *       return '{description} should really be before {date}';\n *     }\n *     if (type === 'after') {\n *       return '{description} should really be after {date}';\n *     }\n *   }\n * })\n * ```\n * The message function is given the following arguments:\n *\n * - `type` (**String**): The error message type\n * - `options` (**Object**): The validator options that were defined in the model\n * - `value`: The current value being evaluated\n * - `context` (**Object**): Context for string replacement\n *\n * The return value must be a `string`. If nothing is returned (`undefined`),\n * defaults to the default error message of the specified type.\n *\n * Within this function, the context is set to that of the current validator.\n * This gives you access to the model, defaultMessages, options and more.\n *\n *\n * @module Validators\n * @submodule Common Options\n */\n\nexport default function(arg1, options) {\n  let props = {\n    options: isNone(options) ? {} : options\n  };\n\n  if (typeof arg1 === 'function') {\n    props.validate = arg1;\n    props._type = 'function';\n  } else if (typeof arg1 === 'string') {\n    props._type = arg1;\n  } else {\n    throw new TypeError('[ember-cp-validations] Unexpected type for first validator argument. It should either be a string or a function');\n  }\n\n  return props;\n}\n","/home/travis/build/npmtest/node-npmtest-ember-cp-validations/node_modules/ember-cp-validations/addon/validators/alias.js":"/**\n * Copyright 2016, Yahoo! Inc.\n * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\nimport Ember from 'ember';\nimport Base from 'ember-cp-validations/validators/base';\n\nconst {\n  get,\n  assert,\n  isPresent,\n  getProperties\n} = Ember;\n\n/**\n *  <i class=\"fa fa-hand-o-right\" aria-hidden=\"true\"></i> [See All Options](#method_validate)\n *\n *  Creates an alias between a single attribute's validations to another.\n *  This copies all messages, errors, etc., to the current attribute as well as\n *  its validation state (isValid, isValidating, etc.)\n *\n *  ## Examples\n *\n *  ```javascript\n *  validator('alias', 'attribute')\n *  validator('alias', {\n *    alias: 'attribute',\n *    firstMessageOnly: true\n *  })\n *  ```\n *\n *  @class Alias\n *  @module Validators\n *  @extends Base\n */\nconst Alias = Base.extend({\n  /**\n   * Normalized options passed in.\n   * ```js\n   * validator('alias', 'attribute')\n   * // Becomes\n   * validator('alias', {\n   *   alias: 'attribute'\n   * })\n   * ```\n   *\n   * @method buildOptions\n   * @param  {Object}     options\n   * @param  {Object}     defaultOptions\n   * @param  {Object}     globalOptions\n   * @return {Object}\n   */\n  buildOptions(options = {}, defaultOptions = {}, globalOptions = {}) {\n    let opts = options;\n\n    if (typeof options === 'string') {\n      opts = {\n        alias: options\n      };\n    }\n    return this._super(opts, defaultOptions, globalOptions);\n  },\n\n  /**\n   * @method validate\n   * @param {Any} value\n   * @param {Object} options\n   * @param {String} options.alias The attribute to alias\n   * @param {Boolean} options.firstMessageOnly If true, only returns the first error message of the\n   *                                           aliased attribute and will not include validation state\n   * @param {Object} model\n   * @param {String} attribute\n   */\n  validate(value, options, model, attribute) {\n    let { alias, firstMessageOnly } = getProperties(options, ['alias', 'firstMessageOnly']);\n\n    assert(`[validator:alias] [${attribute}] option 'alias' is required`, isPresent(alias));\n\n    let aliasValidation = get(model, `validations.attrs.${alias}`);\n\n    return firstMessageOnly ? get(aliasValidation, 'message') : get(aliasValidation, 'content');\n  }\n});\n\nAlias.reopenClass({\n  getDependentsFor(attribute, options) {\n    let alias = typeof options === 'string' ? options : get(options, 'alias');\n\n    assert(`[validator:alias] [${attribute}] 'alias' must be a string`, typeof alias === 'string');\n\n    return [ `${alias}.messages.[]`, `${alias}.isTruelyValid` ];\n  }\n});\n\nexport default Alias;\n","/home/travis/build/npmtest/node-npmtest-ember-cp-validations/node_modules/ember-cp-validations/addon/validators/base.js":"/**\n * Copyright 2016, Yahoo! Inc.\n * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\nimport Ember from 'ember';\nimport Messages from 'ember-cp-validations/validators/messages';\nimport Options from 'ember-cp-validations/-private/options';\nimport { unwrapString, getValidatableValue, mergeOptions } from 'ember-cp-validations/utils/utils';\n\nconst {\n  get,\n  set,\n  isNone,\n  computed,\n  getOwner\n} = Ember;\n\n/**\n * @class Base\n * @module Validators\n */\nconst Base = Ember.Object.extend({\n\n  /**\n   * Options passed in to the validator when defined in the model\n   * @property options\n   * @type {Object}\n   */\n  options: null,\n\n  /**\n   * Default validation options for this specific attribute\n   * @property defaultOptions\n   * @type {Object}\n   */\n  defaultOptions: null,\n\n  /**\n   * Global validation options for this model\n   * @property globalOptions\n   * @type {Object}\n   */\n  globalOptions: null,\n\n  /**\n   * Model instance\n   * @property model\n   * @type {Model}\n   */\n  model: null,\n\n  /**\n   * Attributed name of the model this validator is attached to\n   * @property attribute\n   * @type {String}\n   */\n  attribute: null,\n\n  /**\n   * Error message object. Populated by validators/messages\n   * @property errorMessages\n   * @type {Object}\n   */\n  errorMessages: null,\n\n  /**\n   * @property isWarning\n   * @type {Boolean}\n   */\n  isWarning: computed.bool('options.isWarning').readOnly(),\n\n  /**\n   * Validator type\n   * @property _type\n   * @private\n   * @type {String}\n   */\n  _type: null,\n\n  init() {\n    this._super(...arguments);\n    let globalOptions = get(this, 'globalOptions');\n    let defaultOptions = get(this, 'defaultOptions');\n    let options = get(this, 'options');\n    let owner = getOwner(this);\n    let errorMessages;\n\n    if (!isNone(owner)) {\n      // Since default error messages are stored in app/validators/messages, we have to look it up via the owner\n      errorMessages = owner.factoryFor('validator:messages');\n    }\n\n    // If for some reason, we can't find the messages object (i.e. unit tests), use default\n    errorMessages = errorMessages || Messages;\n\n    set(this, 'options', this.buildOptions(options || {}, defaultOptions || {}, globalOptions || {}));\n    set(this, 'errorMessages', errorMessages.create());\n  },\n\n  /**\n   * Build options hook. Merges default options into options object.\n   * This method gets called on init and is the ideal place to normalize your options.\n   * The [presence validator](https://github.com/offirgolan/ember-cp-validations/blob/master/app/validators/presence.js) is a good example to checkout\n   * @method buildOptions\n   * @param  {Object} options\n   * @param  {Object} defaultOptions\n   * @param  {Object} globalOptions\n   * @return {Object}\n   */\n  buildOptions(options = {}, defaultOptions = {}, globalOptions = {}) {\n    let builtOptions = mergeOptions(options, defaultOptions, globalOptions);\n\n    // Overwrite the validator's value method if it exists in the options and remove it since\n    // there is no need for it to be passed around\n    this.value = builtOptions.value || this.value;\n    delete builtOptions.value;\n\n    return Options.create({\n      model: get(this, 'model'),\n      attribute: get(this, 'attribute'),\n      __options__: builtOptions\n    });\n  },\n\n  /**\n   * Used to retrieve the value to validate.\n   * This method gets called right before `validate` and the returned value\n   * gets passed into the validate method.\n   *\n   * @method value\n   * @param {Object} model\n   * @param {String} attribute\n   * @return The current value of `model[attribute]`\n   */\n  value(model, attribute) {\n    return get(model, attribute);\n  },\n\n  /**\n   * Wrapper method to `value` that passes the necessary parameters\n   *\n   * @method getValue\n   * @private\n   * @return {Mixed} value\n   */\n  getValue() {\n    let value = this.value(get(this, 'model'), get(this, 'attribute'));\n    return getValidatableValue(value);\n  },\n\n  /**\n   * The validate method is where all of your logic should go.\n   * It will get passed in the current value of the attribute this validator is attached to.\n   * Within the validator object, you will have access to the following properties:\n   * @method validate\n   * @param  {Mixed} value        The current value of the attribute\n   * @param  {Object} options       The built and processed options\n   * @param  {Object} model         The current model being evaluated\n   * @param  {String} attribute     The current attribute being evaluated\n   * @return\n   * One of the following types:\n   * - `Boolean`:  `true` if the current value passed the validation\n   * - `String`: The error message\n   * - `Promise`: A promise that will either resolve or reject, and will finally return either `true` or the final error message string.\n   */\n  validate() {\n    return true;\n  },\n\n  /**\n   * Used by all pre-defined validators to build an error message that is present\n   * in `validators/message` or declared in your i18n solution.\n   *\n   * If we extended our default messages to include `uniqueUsername: '{username} already exists'`,\n   * we can use this method to generate our error message.\n   *\n   * ```javascript\n   * validate(value, options) {\n   *   var exists = false;\n   *\n   *   get(options, 'description') = 'Username';\n   *   get(options, 'username') = value;\n   *\n   *   // check with server if username exists...\n   *\n   *   if(exists) {\n   *     return this.createErrorMessage('uniqueUsername', value, options);\n   *   }\n   *\n   *   return true;\n   * }\n   * ```\n   *\n   * If we input `johndoe` and that username already exists, the returned message would be `'johndoe already exists'`.\n   *\n   * @method createErrorMessage\n   * @param  {String} type        The type of message template to use\n   * @param  {Mixed} value                Current value being evaluated\n   * @param  {Object} options     Validator built and processed options (used as the message string context)\n   * @return {String}             The generated message\n   */\n  createErrorMessage(type, value, options = {}) {\n    let messages = this.get('errorMessages');\n    let message = unwrapString(get(options, 'message'));\n\n    set(options, 'description', messages.getDescriptionFor(get(this, 'attribute'), options));\n\n    if (message) {\n      if (typeof message === 'string') {\n        message = messages.formatMessage(message, options);\n      } else if (typeof message === 'function') {\n        message = message.apply(this, arguments);\n        message = isNone(message) ? messages.getMessageFor(type, options) : messages.formatMessage(message, options);\n      }\n    } else {\n      message = messages.getMessageFor(type, options);\n    }\n\n    return message.trim();\n  }\n});\n\nBase.reopenClass({\n  /**\n   * Generate the needed depenent keys for this validator\n   *\n   * @method getDependentsFor\n   * @static\n   * @param  {String} attribute\n   * @param  {Object} options\n   * @return {Array} dependent keys\n   */\n  getDependentsFor() {\n    return [];\n  }\n});\n\nexport default Base;\n\n/**\n * Creating custom validators is very simple. To generate a validator named `unique-username` in Ember CLI\n *\n * ```bash\n * ember generate validator unique-username\n * ```\n *\n * This will create the following files\n *\n * * `app/validators/unique-username.js`\n * * `tests/unit/validators/unique-username-test.js`\n *\n * ```javascript\n * // app/validators/unique-username.js\n *\n * import BaseValidator from 'ember-cp-validations/validators/base';\n *\n * const UniqueUsername = BaseValidator.extend({\n *   validate(value, options, model, attribute) {\n *     return true;\n *   }\n * });\n *\n * UniqueUsername.reopenClass({\n *   getDependentsFor(attribute, options) {\n *     return [];\n *   }\n * });\n *\n * export default UniqueUsername;\n * ```\n *\n * **Side Note**: Before we continue, I would suggest checking out the documentation for the {{#crossLink 'Base'}}Base Validator{{/crossLink}}.\n *\n * If you want to interact with the `store` within your validator, you can simply inject the service like you would a component.\n * Since you have access to your model and the current value, you should be able to send the server the right information to determine if this username is unique.\n *\n * ```javascript\n * // app/validators/unique-username.js\n *\n * import Ember from 'ember';\n * import BaseValidator from 'ember-cp-validations/validators/base';\n *\n * const UniqueUsername = BaseValidator.extend({\n *   store: Ember.inject.service(),\n *\n *   validate(value, options, model, attribute) {\n *     return this.get('store').findRecord('user', value).then((user) => {\n *       if(user && user.id === value) {\n *         let message = `The username '${value}' already exists.`;\n *         let meta = user.get('meta');\n *\n *         if(get(options, 'showSuggestions') && meta && meta.suggestions) {\n *           message += \"What about one of the these: \" + meta.suggestions.join(', ');\n *         }\n *         return message;\n *       } else {\n *         return true;\n *       }\n *     })\n *   }\n * });\n * ```\n *\n * ## Dependent Keys\n *\n * There will be times when your validator will be dependent on some other property or object. Instead of having to\n * include them in your option's `dependentKeys`, you can declare them in the static `getDependentsFor` hook. This hook\n * receives two parameters. The first is the `attribute` that this validator is being added to, and the second are the `options`\n * there were passed to this validator.\n *\n * From the above code sample:\n *\n * ```javascript\n * // app/validators/unique-username.js\n *\n * import BaseValidator from 'ember-cp-validations/validators/base';\n *\n * const UniqueUsername = BaseValidator.extend({});\n *\n * UniqueUsername.reopenClass({\n *   getDependentsFor(attribute, options) {\n *     return [];\n *   }\n * });\n *\n * export default UniqueUsername;\n * ```\n *\n * All dependent keys are in reference to the model's `validations.attrs` object. So when you return `['username']`,\n * it will add a dependent to `model.validations.attrs.username`. If you want to add a dependent on the model, your\n * key needs to be prefixed with `model`. So when you return `['model.username']`, it will add a dependent to `model.username` instead of `model.validations.attrs.username`.\n * This means that if you have a dependent on a service, that service must be injected into the model since returning `['model.myService.someProperty']`\n * will be interpreted as `model.myService.someProperty`.\n *\n * ## Usage\n *\n * To use our unique-username validator we just have to add it to the model definition\n *\n * ```javascript\n * var Validations = buildValidations({\n *   username: validator('unique-username', {\n *     showSuggestions: true\n *   }),\n * });\n *\n * export default DS.Model.extend(Validations, {\n *   'username': DS.attr('string'),\n * });\n * ```\n *\n * ## Testing\n * As mentioned before, the generator created a unit test for your new custom validator.\n *\n * ```javascript\n * // tests/unit/validators/unique-username-test.js\n *\n * import Ember from 'ember';\n * import { moduleFor, test } from 'ember-qunit';\n *\n * moduleFor('validator:unique-username', 'Unit | Validator | unique-username', {\n *     needs: ['validator:messages']\n * });\n *\n * test('it works', function(assert) {\n *     var validator =  this.subject();\n *     assert.ok(validator);\n * });\n * ```\n *\n * A simple test for our validation method can be as such\n *\n * ```javascript\n * test('username is unique', function(assert) {\n *     assert.expect(1);\n *\n *     let validator =  this.subject();\n *     let done = assert.async();\n *\n *     validator.validate('johndoe42').then((message) => {\n *       assert.equal(message, true);\n *       done();\n *     });\n * });\n * ```\n *  @class Custom\n *  @module Validators\n *  @extends Base\n */\n\n/**\n * A validator can also be declared with an inline function. The function will be then wrapped in the {{#crossLink 'Base'}}Base Validator{{/crossLink}} class and used just like any other pre-defined validator.\n *\n * ```javascript\n * // Example\n * validator(function(value, options, model, attribute) {\n *   return value === get(options, 'username') ? true : `must be ${get(options, 'username')}`;\n * } , {\n *   username: 'John' // Any options can be passed here\n * })\n * ```\n *\n * @class Inline\n * @module Validators\n * @extends Base\n */\n","/home/travis/build/npmtest/node-npmtest-ember-cp-validations/node_modules/ember-cp-validations/addon/validators/belongs-to.js":"/**\n * Copyright 2016, Yahoo! Inc.\n * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\nimport Ember from 'ember';\nimport Base from 'ember-cp-validations/validators/base';\nimport { isPromise } from 'ember-cp-validations/utils/utils';\n\nconst {\n  get\n} = Ember;\n\n/**\n *  <i class=\"fa fa-hand-o-right\" aria-hidden=\"true\"></i> [See All Options](#method_validate)\n *\n *  Identifies a `belongs-to` relationship in an Ember Data Model or Ember.Object.\n *  This is used to create a link to the validations object of the child model.\n *\n *  _**Note:** Validations must exist on **both** models/objects_\n *\n *  ### Ember Model\n *\n *  ```javascript\n *  // model/users.js\n *\n *  const Validations = buildValidations({\n *    details: validator('belongs-to')\n *  });\n *\n *  export default DS.Model.extend(Validations, {\n *    'details': DS.belongsTo('user-detail')\n *  });\n *  ```\n *\n *  ```javascript\n *  // model/user-details.js\n *\n *  const Validations = buildValidations({\n *    firstName: validator('presence', true),\n *    lastName: validator('presence', true)\n *  });\n *\n *  export default DS.Model.extend(Validations, {\n *    \"firstName\": attr('string'),\n *    \"lastName\": attr('string'),\n *  });\n *  ```\n *\n *  ### Ember Object\n *\n *  ```javascript\n *  // model/users.js\n *\n *  import UserDetails from '../user-details';\n *\n *  const Validations = buildValidations({\n *    details: validator('belongs-to')\n *  });\n *\n *  export default Ember.Object.extend(Validations, {\n *    details: null,\n *\n *    init() {\n *      this._super(...arguments);\n *      let owner = Ember.getOwner(this);\n *      this.set('details', UserDetails.create(owner.ownerInjection()));\n *    }\n *  });\n *  ```\n *\n *  From our `user` model, we can now check any validation property on the `user-details` model.\n *\n *  ```javascript\n *  get(model, 'validations.attrs.details.isValid')\n *  get(model, 'validations.attrs.details.messages')\n *  ```\n *\n *  @class Belongs To\n *  @module Validators\n *  @extends Base\n */\nconst BelongsTo = Base.extend({\n  validate(value) {\n    if (value) {\n      if (isPromise(value)) {\n        return value.then((model) => model ? get(model, 'validations') : true);\n      }\n      return get(value, 'validations');\n    }\n\n    return true;\n  }\n});\n\nBelongsTo.reopenClass({\n  getDependentsFor(attribute) {\n    return [ `model.${attribute}.isDeleted` ];\n  }\n});\n\nexport default BelongsTo;\n","/home/travis/build/npmtest/node-npmtest-ember-cp-validations/node_modules/ember-cp-validations/addon/validators/collection.js":"/**\n * Copyright 2016, Yahoo! Inc.\n * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\nimport Ember from 'ember';\nimport EmberValidator from 'ember-cp-validations/-private/ember-validator';\n\nconst {\n  get\n} = Ember;\n\n/**\n *  <i class=\"fa fa-hand-o-right\" aria-hidden=\"true\"></i> [See All Options](#method_validate)\n *\n *  If `true` validates that the given value is a valid collection and will add `<ATTRIBUTE>.[]` as a dependent key to the CP.\n *  If `false`, validates that the given value is singular. Use this validator if you want validation to occur when the content of your collection changes.\n *\n *  ## Examples\n *\n *  ```javascript\n *  validator('collection', true)\n *  validator('collection', false)\n *  validator('collection', {\n *    collection: true,\n *    message: 'must be a collection'\n *  })\n *  ```\n *\n *  @class Collection\n *  @module Validators\n *  @extends Base\n */\nconst Collection = EmberValidator.extend({\n  _evType: 'collection',\n\n  /**\n   * Normalized options passed in.\n   * ```js\n   * validator('collection', true)\n   * // Becomes\n   * validator('collection', {\n   *   collection: true\n   * })\n   * ```\n   *\n   * @method buildOptions\n   * @param  {Object}     options\n   * @param  {Object}     defaultOptions\n   * @param  {Object}     globalOptions\n   * @return {Object}\n   */\n  buildOptions(options = {}, defaultOptions = {}, globalOptions = {}) {\n    let opts = options;\n\n    if (typeof options === 'boolean') {\n      opts = {\n        collection: options\n      };\n    }\n    return this._super(opts, defaultOptions, globalOptions);\n  }\n});\n\nCollection.reopenClass({\n  getDependentsFor(attribute, options) {\n    return (options === true || get(options, 'collection') === true) ? [`model.${attribute}.[]`] : [];\n  }\n});\n\nexport default Collection;\n","/home/travis/build/npmtest/node-npmtest-ember-cp-validations/node_modules/ember-cp-validations/addon/validators/confirmation.js":"/**\n * Copyright 2016, Yahoo! Inc.\n * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\nimport Ember from 'ember';\nimport EmberValidator from 'ember-cp-validations/-private/ember-validator';\n\nconst {\n  get,\n  assert\n} = Ember;\n\n/**\n *  <i class=\"fa fa-hand-o-right\" aria-hidden=\"true\"></i> [See All Options](#method_validate)\n *\n *  Validates that the attribute has the same value as the one of the declared attribute.\n *\n *  ## Examples\n *\n *  ```javascript\n *  email: validator('format', {\n *    type: 'email'\n *  })\n *  verifiedEmail: validator('confirmation', {\n *    on: 'email',\n *    message: 'Email addresses do not match'\n *  })\n *  ```\n *\n *  @class Confirmation\n *  @module Validators\n *  @extends Base\n */\nconst Confirmation = EmberValidator.extend({\n  _evType: 'confirmation'\n});\n\nConfirmation.reopenClass({\n  getDependentsFor(attribute, options) {\n    let on = get(options, 'on');\n\n    assert(`[validator:confirmation] [${attribute}] 'on' must be a string`, typeof on === 'string');\n\n    return on ? [`model.${on}`] : [];\n  }\n});\n\nexport default Confirmation;\n","/home/travis/build/npmtest/node-npmtest-ember-cp-validations/node_modules/ember-cp-validations/addon/validators/date.js":"/**\n * Copyright 2016, Yahoo! Inc.\n * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\nimport EmberValidator from 'ember-cp-validations/-private/ember-validator';\n\n/**\n *  <i class=\"fa fa-hand-o-right\" aria-hidden=\"true\"></i> [See All Options](#method_validate)\n *\n *  Validate over a date range. Uses [MomentJS](http://momentjs.com/) for date mathematics and calculations.\n *\n *  **Note**: MomentJS must be installed to be able to use this validator. The easiest way to do this is to install [ember-moment](https://github.com/stefanpenner/ember-moment)\n *\n * ## Examples\n *\n * If `before`, `onOrBefore`, `after`, or `onOrAfter` is set to **now**, the value given to the validator will be tested against the current date and time.\n *\n *  ```javascript\n *  validator('date', {\n *    after: 'now',\n *    before: '1/1/2020',\n *    precision: 'day',\n *    format: 'M/D/YYY',\n *    errorFormat: 'M/D/YYY'\n *  })\n *  ```\n *\n *  @class Date\n *  @module Validators\n *  @extends Base\n */\nexport default EmberValidator.extend({\n  _evType: 'date'\n});\n","/home/travis/build/npmtest/node-npmtest-ember-cp-validations/node_modules/ember-cp-validations/addon/validators/dependent.js":"/**\n * Copyright 2016, Yahoo! Inc.\n * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\nimport Ember from 'ember';\nimport Base from 'ember-cp-validations/validators/base';\n\nconst {\n  A,\n  get,\n  getWithDefault,\n  getProperties,\n  assert,\n  isNone,\n  isEmpty,\n  isPresent,\n  isArray\n} = Ember;\n\n/**\n *  <i class=\"fa fa-hand-o-right\" aria-hidden=\"true\"></i> [See All Options](#method_validate)\n *\n *  Defines an attribute as valid only if its dependents are valid.\n *\n *  ## Example\n *\n *  ```javascript\n *  // Full name will only be valid if firstName and lastName are filled in\n *  validator('dependent', {\n *    on: ['firstName', 'lastName']\n *  })\n *  ```\n *\n *  @class Dependent\n *  @module Validators\n *  @extends Base\n */\nconst Dependent = Base.extend({\n  /**\n   * @method validate\n   * @param {Any} value\n   * @param {Object} options\n   * @param {Array} options.on Attributes this field is dependent on\n   * @param {Object} model\n   * @param {String} attribute\n   */\n  validate(value, options, model, attribute) {\n    let { on, allowBlank } = getProperties(options, ['on', 'allowBlank']);\n\n    assert(`[validator:dependent] [${attribute}] option 'on' is required`, isPresent(on));\n\n    if (isNone(model)) {\n      return true;\n    }\n\n    if (allowBlank && isEmpty(value)) {\n      return true;\n    }\n\n    let dependentValidations = getWithDefault(options, 'on', A()).map((dependent) => get(model, `validations.attrs.${dependent}`));\n\n    if (!isEmpty(dependentValidations.filter((v) => !get(v, 'isTruelyValid')))) {\n      return this.createErrorMessage('invalid', value, options);\n    }\n\n    return true;\n  }\n});\n\nDependent.reopenClass({\n  getDependentsFor(attribute, options) {\n    let dependents = get(options, 'on');\n\n    assert(`[validator:dependent] [${attribute}] 'on' must be an array`, isArray(dependents));\n\n    if (!isEmpty(dependents)) {\n      return dependents.map((dependent) => `${dependent}.isTruelyValid`);\n    }\n\n    return [];\n  }\n});\n\nexport default Dependent;\n","/home/travis/build/npmtest/node-npmtest-ember-cp-validations/node_modules/ember-cp-validations/addon/validators/ds-error.js":"/**\n * Copyright 2016, Yahoo! Inc.\n * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\nimport EmberValidator from 'ember-cp-validations/-private/ember-validator';\nimport { getPathAndKey } from 'ember-validators/ds-error';\n\n/**\n *  <i class=\"fa fa-hand-o-right\" aria-hidden=\"true\"></i> [See All Options](#method_validate)\n *\n *  Creates a link between this library and Ember-Data's [DS.Errors](http://emberjs.com/api/data/classes/DS.Errors.html)\n *  to fetch the latest message for the given attribute.\n *\n *  ## Examples\n *\n *  ```javascript\n *  validator('ds-error')\n *  ```\n *\n *  @class DS Error\n *  @module Validators\n *  @extends Base\n */\nconst DSError = EmberValidator.extend({\n  _evType: 'ds-error'\n});\n\nDSError.reopenClass({\n  getDependentsFor(attribute) {\n    let { path, key } = getPathAndKey(attribute);\n\n    return [`model.${path}.${key}.[]`];\n  }\n});\n\nexport default DSError;\n","/home/travis/build/npmtest/node-npmtest-ember-cp-validations/node_modules/ember-cp-validations/addon/validators/exclusion.js":"/**\n * Copyright 2016, Yahoo! Inc.\n * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\nimport EmberValidator from 'ember-cp-validations/-private/ember-validator';\n\n/**\n *  <i class=\"fa fa-hand-o-right\" aria-hidden=\"true\"></i> [See All Options](#method_validate)\n *\n *  Validates that the attributes’ values are not included in a given list. All comparisons are done using strict equality so type matters! For range, the value type is checked against both lower and upper bounds for type equality.\n *\n *  ## Examples:\n *\n *  ```javascript\n *  validator('exclusion', {\n *    in: ['Admin', 'Super Admin']\n *  })\n *  validator('exclusion', {\n *    range: [0, 5] // Cannot be between 0 (inclusive) to 5 (inclusive)\n *  })\n *  ```\n *\n *  @class Exclusion\n *  @module Validators\n *  @extends Base\n */\nexport default EmberValidator.extend({\n  _evType: 'exclusion'\n});\n","/home/travis/build/npmtest/node-npmtest-ember-cp-validations/node_modules/ember-cp-validations/addon/validators/format.js":"/**\n * Copyright 2016, Yahoo! Inc.\n * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\nimport EmberValidator from 'ember-cp-validations/-private/ember-validator';\nimport { regularExpressions } from 'ember-validators/format';\n\n/**\n *  <i class=\"fa fa-hand-o-right\" aria-hidden=\"true\"></i> [See All Options](#method_validate)\n *\n *  Validate over a predefined or custom regular expression.\n *\n *  ## Examples\n *\n *  ```javascript\n *  validator('format', {\n *    type: 'email',\n *    allowNonTld: true\n *  })\n *  validator('format', {\n *    allowBlank: true,\n *    type: 'phone'\n *  })\n *  validator('format', {\n *    type: 'url'\n *  })\n *  validator('format', {\n *    regex: /^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{4,8}$/,\n *    message: 'Password must include at least one upper case letter, one lower case letter, and a number'\n *  })\n *  ```\n *\n *  If you do not want to use the predefined regex for a specific type, you can do something like this\n *\n *  ```javascript\n *  validator('format', {\n *    type: 'email',\n *    regex: /My Better Email Regexp/\n *  })\n *  ```\n *\n *  This allows you to still keep the email error message but with your own custom regex.\n *\n *  @class Format\n *  @module Validators\n *  @extends Base\n */\nexport default EmberValidator.extend({\n  _evType: 'format',\n  regularExpressions\n});\n","/home/travis/build/npmtest/node-npmtest-ember-cp-validations/node_modules/ember-cp-validations/addon/validators/has-many.js":"/**\n * Copyright 2016, Yahoo! Inc.\n * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\nimport Base from 'ember-cp-validations/validators/base';\nimport { isPromise } from 'ember-cp-validations/utils/utils';\n\n/**\n *  <i class=\"fa fa-hand-o-right\" aria-hidden=\"true\"></i> [See All Options](#method_validate)\n *\n *  Identifies a `has-many` relationship in an Ember Data Model or Ember.Object.\n *  This is used to create a validation collection of the `has-many` validations.\n *\n *  _**Note:** Validations must exist on **all** models/objects_\n *\n *  ### Ember Models\n *\n *  ```javascript\n *  // model/users.js\n *\n *  const Validations = buildValidations({\n *    friends: validator('has-many')\n *  });\n *\n *  export default DS.Model.extend(Validations, {\n *    friends: DS.hasMany('user')\n *  });\n *  ```\n *\n *  ### Ember Objects\n *\n *  ```javascript\n *  // model/users.js\n *\n *  const Validations = buildValidations({\n *    friends: validator('has-many')\n *  });\n *\n *  export default Ember.Object.extend(Validations, {\n *    friends: null\n *  });\n *  ```\n *\n *  From our `user` model, we can now check validation properties on the `friends` attribute.\n *\n *  ```javascript\n *  get(model, 'validations.attrs.friends.isValid')\n *  get(model, 'validations.attrs.friends.messages')\n *  ```\n *\n *  @class Has Many\n *  @module Validators\n *  @extends Base\n */\nconst HasMany = Base.extend({\n  validate(value) {\n    if (value) {\n      if (isPromise(value)) {\n        return value.then((models) => models ? models.map((m) => m.get('validations')) : true);\n      }\n      return value.map((m) => m.get('validations'));\n    }\n\n    return true;\n  }\n});\n\nHasMany.reopenClass({\n  getDependentsFor(attribute) {\n    /*\n      The content.@each.isDeleted must be added for older ember-data versions\n     */\n    return [ `model.${attribute}.[]`, `model.${attribute}.@each.isDeleted`, `model.${attribute}.content.@each.isDeleted` ];\n  }\n});\n\nexport default HasMany;\n","/home/travis/build/npmtest/node-npmtest-ember-cp-validations/node_modules/ember-cp-validations/addon/validators/inclusion.js":"/**\n * Copyright 2016, Yahoo! Inc.\n * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\nimport EmberValidator from 'ember-cp-validations/-private/ember-validator';\n\n/**\n *  <i class=\"fa fa-hand-o-right\" aria-hidden=\"true\"></i> [See All Options](#method_validate)\n *\n *  Validates that the attributes’ values are included in a given list. All comparisons are done using strict equality so type matters!\n *  For range, the value type is checked against both lower and upper bounds for type equality.\n *\n *  ## Examples\n *\n *  ```javascript\n *  validator('inclusion', {\n *    in: ['User', 'Admin']\n *  })\n *  validator('inclusion', {\n *    range: [0, 5] // Must be between 0 (inclusive) to 5 (inclusive)\n *  })\n *  ```\n *\n *  Because of the strict equality comparisons, you can use this validator in many different ways.\n *\n *  ```javascript\n *  validator('inclusion', {\n *    in: ['Admin'] // Input must be equal to 'Admin'\n *  })\n *  validator('inclusion', {\n *    range: [0, Infinity] // Input must be positive number\n *  })\n *  validator('inclusion', {\n *    range: [-Infinity, Infinity] // Input must be a number\n *  })\n *  ```\n *\n *  @class Inclusion\n *  @module Validators\n *  @extends Base\n */\nexport default EmberValidator.extend({\n  _evType: 'inclusion'\n});\n","/home/travis/build/npmtest/node-npmtest-ember-cp-validations/node_modules/ember-cp-validations/addon/validators/length.js":"/**\n * Copyright 2016, Yahoo! Inc.\n * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\nimport EmberValidator from 'ember-cp-validations/-private/ember-validator';\n\n/**\n *  <i class=\"fa fa-hand-o-right\" aria-hidden=\"true\"></i> [See All Options](#method_validate)\n *\n *  Validates the length of the attributes’ values.\n *\n *  ## Examples\n *\n *  ```javascript\n *  validator('length', {\n *    is: 15\n *  })\n *  validator('length', {\n *    min: 5,\n *    max: 10\n *  })\n *  ```\n *\n *  @class Length\n *  @module Validators\n *  @extends Base\n */\nexport default EmberValidator.extend({\n  _evType: 'length'\n});\n","/home/travis/build/npmtest/node-npmtest-ember-cp-validations/node_modules/ember-cp-validations/addon/validators/messages.js":"/**\n * Copyright 2016, Yahoo! Inc.\n * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\nimport Ember from 'ember';\nimport Messages from 'ember-validators/messages';\n\n/**\n *  The default validation error messages are imported in your app's `validators` folder.\n *  If you want to change or extend them, all you need to do is create a `messages.js` file under `app/validators`.\n *\n *  ```javascript\n *  // app/validators/messages.js\n *\n *  import Messages from 'ember-cp-validations/validators/messages';\n *\n *  export default Messages.extend({\n *    uniqueUsername: '{description} {username} already exists'\n *  });\n *  ```\n *\n *  Within this object, you can overwrite the [default messages](https://github.com/offirgolan/ember-cp-validations/blob/master/addon/validators/messages.js) or create new messages just like in the example above.\n *  If a message of a given type is not found, it will default to the `invalid` message.\n *  Usage examples can be found {{#crossLink \"Base/createErrorMessage:method\"}}here{{/crossLink}}\n *\n *  @class Messages\n *  @module Validators\n */\nexport default Ember.Object.extend(Messages);\n","/home/travis/build/npmtest/node-npmtest-ember-cp-validations/node_modules/ember-cp-validations/addon/validators/number.js":"/**\n * Copyright 2016, Yahoo! Inc.\n * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\nimport EmberValidator from 'ember-cp-validations/-private/ember-validator';\n\n/**\n *  <i class=\"fa fa-hand-o-right\" aria-hidden=\"true\"></i> [See All Options](#method_validate)\n *\n *  Validates that your attributes have only numeric values.\n *\n *  ## Examples\n *\n *  ```javascript\n *  validator('number') // Simple check if the value is a number\n *  validator('number', {\n *    allowString: true,\n *    integer: true,\n *    gt: 5,\n *    lte: 100\n *  })\n *  ```\n *\n *  @class Number\n *  @module Validators\n *  @extends Base\n */\nexport default EmberValidator.extend({\n  _evType: 'number'\n});\n","/home/travis/build/npmtest/node-npmtest-ember-cp-validations/node_modules/ember-cp-validations/addon/validators/presence.js":"/**\n * Copyright 2016, Yahoo! Inc.\n * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\nimport EmberValidator from 'ember-cp-validations/-private/ember-validator';\n\n/**\n *  <i class=\"fa fa-hand-o-right\" aria-hidden=\"true\"></i> [See All Options](#method_validate)\n *\n *  If `true` validates that the given value is not empty, if `false`, validates that the given value is empty.\n *\n *  ## Examples\n *\n *  ```javascript\n *  validator('presence', true)\n *  validator('presence', false)\n *  validator('presence', {\n *    presence: true,\n *    message: 'should not be empty'\n *  })\n *\n *  validator('presence', {\n *    presence: true,\n *    ignoreBlank: true,\n *    message: 'should not be empty or consist only of spaces'\n *  })\n *  ```\n *\n *  @class Presence\n *  @module Validators\n *  @extends Base\n */\nexport default EmberValidator.extend({\n  _evType: 'presence',\n\n  /**\n   * Normalized options passed in.\n   * ```js\n   * validator('presence', true)\n   * // Becomes\n   * validator('presence', {\n   *   presence: true\n   * })\n   * ```\n   *\n   * @method buildOptions\n   * @param  {Object}     options\n   * @param  {Object}     defaultOptions\n   * @param  {Object}     globalOptions\n   * @return {Object}\n   */\n  buildOptions(options = {}, defaultOptions = {}, globalOptions = {}) {\n    let opts = options;\n\n    if (typeof options === 'boolean') {\n      opts = {\n        presence: options\n      };\n    }\n    return this._super(opts, defaultOptions, globalOptions);\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-ember-cp-validations/node_modules/ember-cp-validations/app/validators/alias.js":"export { default } from 'ember-cp-validations/validators/alias';\n","/home/travis/build/npmtest/node-npmtest-ember-cp-validations/node_modules/ember-cp-validations/app/validators/belongs-to.js":"export { default } from 'ember-cp-validations/validators/belongs-to';\n","/home/travis/build/npmtest/node-npmtest-ember-cp-validations/node_modules/ember-cp-validations/app/validators/collection.js":"export { default } from 'ember-cp-validations/validators/collection';\n","/home/travis/build/npmtest/node-npmtest-ember-cp-validations/node_modules/ember-cp-validations/app/validators/confirmation.js":"export { default } from 'ember-cp-validations/validators/confirmation';\n","/home/travis/build/npmtest/node-npmtest-ember-cp-validations/node_modules/ember-cp-validations/app/validators/date.js":"export { default } from 'ember-cp-validations/validators/date';\n","/home/travis/build/npmtest/node-npmtest-ember-cp-validations/node_modules/ember-cp-validations/app/validators/dependent.js":"export { default } from 'ember-cp-validations/validators/dependent';\n","/home/travis/build/npmtest/node-npmtest-ember-cp-validations/node_modules/ember-cp-validations/app/validators/ds-error.js":"export { default } from 'ember-cp-validations/validators/ds-error';\n","/home/travis/build/npmtest/node-npmtest-ember-cp-validations/node_modules/ember-cp-validations/app/validators/exclusion.js":"export { default } from 'ember-cp-validations/validators/exclusion';\n","/home/travis/build/npmtest/node-npmtest-ember-cp-validations/node_modules/ember-cp-validations/app/validators/format.js":"export { default } from 'ember-cp-validations/validators/format';\n","/home/travis/build/npmtest/node-npmtest-ember-cp-validations/node_modules/ember-cp-validations/app/validators/has-many.js":"export { default } from 'ember-cp-validations/validators/has-many';\n","/home/travis/build/npmtest/node-npmtest-ember-cp-validations/node_modules/ember-cp-validations/app/validators/inclusion.js":"export { default } from 'ember-cp-validations/validators/inclusion';\n","/home/travis/build/npmtest/node-npmtest-ember-cp-validations/node_modules/ember-cp-validations/app/validators/length.js":"export { default } from 'ember-cp-validations/validators/length';\n","/home/travis/build/npmtest/node-npmtest-ember-cp-validations/node_modules/ember-cp-validations/app/validators/messages.js":"/**\n * Copyright 2016, Yahoo! Inc.\n * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\nexport { default } from 'ember-cp-validations/validators/messages';\n","/home/travis/build/npmtest/node-npmtest-ember-cp-validations/node_modules/ember-cp-validations/app/validators/number.js":"export { default } from 'ember-cp-validations/validators/number';\n","/home/travis/build/npmtest/node-npmtest-ember-cp-validations/node_modules/ember-cp-validations/app/validators/presence.js":"export { default } from 'ember-cp-validations/validators/presence';\n"}